<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/02/hello-world/"/>
      <url>/2020/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven的下载安装与配置</title>
      <link href="/2020/03/01/Maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/01/Maven%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven下载"><a href="#Maven下载" class="headerlink" title="Maven下载"></a>Maven下载</h1><p>Maven官网：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a><br>解压到<code>E:\Program Files (x86)\Java</code>文件夹下；<br>添加系统环境变量<code>MAVEN_HOME</code>，值为<code>E:\Program Files (x86)\Java\apache-maven-3.6.3</code>；<br>编辑系统环境变量<code>Path</code>，追加<code>%MAVEN_HOME%\bin\;</code>；<br>使用<code>mvn -v</code>命令检查一下我们是否安装成功。</p><a id="more"></a><h1 id="配置Maven本地仓库"><a href="#配置Maven本地仓库" class="headerlink" title="配置Maven本地仓库"></a>配置Maven本地仓库</h1><p>在<code>E:\Program Files (x86)\Java\apache-maven-3.6.3</code>目录下新建<code>repository</code>文件夹，该目录用作maven的本地库。打开<code>E:\Program Files (x86)\Java\apache-maven-3.6.3\conf\settings.xml</code>文件，查找下面这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure><p>localRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们创建的本地仓库目录，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;E:\Program Files (x86)\Java\apache-maven-3.6.3\repository&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure><p>运行一下DOS命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn help:system</span><br></pre></td></tr></table></figure><p>如果前面的配置成功，那么<code>E:\Program Files (x86)\Java\apache-maven-3.6.3\repository</code>会出现一些文件。</p><h1 id="配置Maven阿里云镜像"><a href="#配置Maven阿里云镜像" class="headerlink" title="配置Maven阿里云镜像"></a>配置Maven阿里云镜像</h1><p>在<code>settings.xml</code>文件中的mirrors下添加mirror标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>用Maven命令创建一个Java项目，可以看到初次创建会加载一些jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeArtifactId&#x3D;maven-archetype-quickstart -DgroupId&#x3D;com.abc -DartifactId&#x3D;Blog</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入（DI）</title>
      <link href="/2020/02/29/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/"/>
      <url>/2020/02/29/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><p>依赖注入（Dependency Injection,DI）。<br><strong>依赖</strong> : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .<br><strong>注入</strong> : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</p><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="通过无参构造方法来创建"><a href="#通过无参构造方法来创建" class="headerlink" title="通过无参构造方法来创建"></a>通过无参构造方法来创建</h3><p>1、User.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">        System.out.println(&quot;user无参构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、beans.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;kuangshen&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>3、测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    &#x2F;&#x2F;在执行getBean的时候, user已经创建好了 , 通过无参构造</span><br><span class="line">    User user &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    &#x2F;&#x2F;调用对象的方法 .</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p><h3 id="通过有参构造方法来创建"><a href="#通过有参构造方法来创建" class="headerlink" title="通过有参构造方法来创建"></a>通过有参构造方法来创建</h3><p>1、UserT.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UserT &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public UserT(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、beans.xml 有三种方式编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;!-- index指构造方法 , 下标从0开始 --&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;!-- name指参数名 --&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第三种根据参数类型设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testT()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    UserT user &#x3D; (UserT) context.getBean(&quot;userT&quot;);</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在配置文件加载的时候,其中管理的对象都已经初始化了！</p><h2 id="setter注入-重点"><a href="#setter注入-重点" class="headerlink" title="setter注入 (重点)"></a>setter注入 (重点)</h2><p>要求被注入的属性 , 必须有set方法 , set方法的方法名:<code>set + 属性首字母大写</code> .<br>Address.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] books;</span><br><span class="line">    private List&lt;String&gt; hobbys;</span><br><span class="line">    private Map&lt;String,String&gt; card;</span><br><span class="line">    private Set&lt;String&gt; games;</span><br><span class="line">    private String wife;</span><br><span class="line">    private Properties info;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBooks(String[] books) &#123;</span><br><span class="line">        this.books &#x3D; books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbys(List&lt;String&gt; hobbys) &#123;</span><br><span class="line">        this.hobbys &#x3D; hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Map&lt;String, String&gt; card) &#123;</span><br><span class="line">        this.card &#x3D; card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGames(Set&lt;String&gt; games) &#123;</span><br><span class="line">        this.games &#x3D; games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWife(String wife) &#123;</span><br><span class="line">        this.wife &#x3D; wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfo(Properties info) &#123;</span><br><span class="line">        this.info &#x3D; info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name</span><br><span class="line">                + &quot;,address&#x3D;&quot;+ address.getAddress()</span><br><span class="line">                + &quot;,books&#x3D;&quot;</span><br><span class="line">        );</span><br><span class="line">        for (String book:books)&#123;</span><br><span class="line">            System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;\n爱好:&quot;+hobbys);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;card:&quot;+card);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;games:&quot;+games);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;wife:&quot;+wife);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;info:&quot;+info);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量注入"><a href="#常量注入" class="headerlink" title="常量注入"></a>常量注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="Bean注入"><a href="#Bean注入" class="headerlink" title="Bean注入"></a>Bean注入</h3><p>注意点：这里的值是一个引用，ref</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;addr&quot; class&#x3D;&quot;com.kuang.pojo.Address&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; value&#x3D;&quot;重庆&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;addr&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;addr&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;books&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;西游记&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;水浒传&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;array&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="List注入"><a href="#List注入" class="headerlink" title="List注入"></a>List注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;hobbys&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;听歌&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;看电影&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;爬山&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;list&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><h3 id="Map注入"><a href="#Map注入" class="headerlink" title="Map注入"></a>Map注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;card&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;110231199008242278&quot;&#x2F;&gt;</span><br><span class="line">        &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;6207882730089376212&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;map&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><h3 id="Set注入"><a href="#Set注入" class="headerlink" title="Set注入"></a>Set注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;games&quot;&gt;</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;value&gt;LOL&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;BOB&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;value&gt;COC&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><h3 id="Null注入"><a href="#Null注入" class="headerlink" title="Null注入"></a>Null注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;wife&quot;&gt;&lt;null&#x2F;&gt;&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><h3 id="Properties注入"><a href="#Properties注入" class="headerlink" title="Properties注入"></a>Properties注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;info&quot;&gt;</span><br><span class="line">    &lt;props&gt;</span><br><span class="line">        &lt;prop key&#x3D;&quot;学号&quot;&gt;20190604&lt;&#x2F;prop&gt;</span><br><span class="line">        &lt;prop key&#x3D;&quot;性别&quot;&gt;男&lt;&#x2F;prop&gt;</span><br><span class="line">        &lt;prop key&#x3D;&quot;姓名&quot;&gt;小明&lt;&#x2F;prop&gt;</span><br><span class="line">    &lt;&#x2F;props&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    Student student &#x3D; (Student) context.getBean(&quot;student&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展注入实现"><a href="#拓展注入实现" class="headerlink" title="拓展注入实现"></a>拓展注入实现</h1><p>User.java ： 【注意：这里没有有参构造器！】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p命名空间注入-需要在头文件中加入约束文件"><a href="#p命名空间注入-需要在头文件中加入约束文件" class="headerlink" title="p命名空间注入: 需要在头文件中加入约束文件"></a>p命名空间注入: 需要在头文件中加入约束文件</h2><p>导入约束 : <code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; p:name&#x3D;&quot;狂神&quot; p:age&#x3D;&quot;18&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="c-命名空间注入-需要在头文件中加入约束文件"><a href="#c-命名空间注入-需要在头文件中加入约束文件" class="headerlink" title="c 命名空间注入: 需要在头文件中加入约束文件"></a>c 命名空间注入: 需要在头文件中加入约束文件</h2><p>导入约束 : <code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot; c:name&#x3D;&quot;狂神&quot; c:age&#x3D;&quot;18&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .<br><img src="https://i.loli.net/2020/02/29/Ac4TPDSXrv6NW9K.png" alt="Bean作用域.png" title="Bean作用域"><br>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;ServiceImpl&quot; class&#x3D;&quot;cn.csdn.service.ServiceImpl&quot; scope&#x3D;&quot;singleton&quot;&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test03()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    User user &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    User user2 &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    System.out.println(user&#x3D;&#x3D;user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;account&quot; class&#x3D;&quot;com.foo.DefaultAccount&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;cn.csdn.LoginAction&quot; scope&#x3D;&quot;request&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.foo.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p><h2 id="Global-Session"><a href="#Global-Session" class="headerlink" title="Global Session"></a>Global Session</h2><p>当一个bean的作用域为Global Session，表示在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;color:#000000&quot;&gt;&lt;code&gt;&lt;bean id&#x3D;&lt;span style&#x3D;&quot;color:#009900&quot;&gt;&quot;user&quot;&lt;&#x2F;span&gt; &lt;span style&#x3D;&quot;color:#000088&quot;&gt;class&lt;&#x2F;span&gt;&#x3D;&lt;span style&#x3D;&quot;color:#009900&quot;&gt;&quot;com.foo.Preferences &quot;&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;color:#000088&quot;&gt;scope&lt;&#x2F;span&gt;&#x3D;&lt;span style&#x3D;&quot;color:#009900&quot;&gt;&quot;globalSession&quot;&lt;&#x2F;span&gt;&#x2F;&gt;&lt;&#x2F;code&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p><p>参考文献：<a href="https://blog.kuangstudy.com/index.php/archives/520/" target="_blank" rel="noopener">Spring：依赖注入（DI）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DI </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门</title>
      <link href="/2020/02/29/Spring%E5%85%A5%E9%97%A8/"/>
      <url>/2020/02/29/Spring%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h1><p>spring 需要导入commons-logging进行日志记录,我们利用maven,他会自动下载对应的依赖项.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.10.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p>编写一个Hello实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;Hello,&quot;+ name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写我们的spring文件 , 这里我们命名为beans.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.kuang.pojo.Hello&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Spring&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>我们可以去进行测试了 .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    &#x2F;&#x2F;解析beans.xml文件 , 生成管理相应的Bean对象</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    &#x2F;&#x2F;getBean : 参数即为spring配置文件中bean的id .</span><br><span class="line">    Hello hello &#x3D; (Hello) context.getBean(&quot;hello&quot;);</span><br><span class="line">    hello.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Hello 对象是谁创建的 ? 【 hello 对象是由Spring创建的 】<br>Hello 对象的属性是怎么设置的 ? 【hello 对象的属性是由Spring容器设置的 】<br><strong>控制反转</strong>：</p><ul><li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li><li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li><li><em>依赖注入*</em> : 就是利用set方法来进行注入的.<br>IOC是一种编程思想，由主动的编程变成被动的接收.</li></ul><h1 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h1><h2 id="通过无参构造方法来创建"><a href="#通过无参构造方法来创建" class="headerlink" title="通过无参构造方法来创建"></a>通过无参构造方法来创建</h2><p>1、User.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">        System.out.println(&quot;user无参构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、beans.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;kuangshen&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>3、测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    &#x2F;&#x2F;在执行getBean的时候, user已经创建好了 , 通过无参构造</span><br><span class="line">    User user &#x3D; (User) context.getBean(&quot;user&quot;);</span><br><span class="line">    &#x2F;&#x2F;调用对象的方法 .</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！<br>##通过有参构造方法来创建</p><p>1、UserT.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UserT &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public UserT(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;name&#x3D;&quot;+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、beans.xml 有三种方式编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;!-- index指构造方法 , 下标从0开始 --&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;!-- name指参数名 --&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第三种根据参数类型设置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userT&quot; class&#x3D;&quot;com.kuang.pojo.UserT&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;kuangshen2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testT()&#123;</span><br><span class="line">    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">    UserT user &#x3D; (UserT) context.getBean(&quot;userT&quot;);</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在配置文件加载的时候,其中管理的对象都已经初始化了！</p><h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p><code>alias</code> 设置别名 , 为bean设置别名 , 可以设置多个别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span><br><span class="line">&lt;alias name&#x3D;&quot;userT&quot; alias&#x3D;&quot;userNew&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span><br><span class="line">    如果配置id,又配置了name,那么name是别名</span><br><span class="line">    name可以设置多个别名,可以用逗号、分号、空格隔开</span><br><span class="line">    如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span><br><span class="line">    class是bean的全限定名:包名+类名</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;hello&quot; name&#x3D;&quot;hello2 h2,h3;h4&quot; class&#x3D;&quot;com.kuang.pojo.Hello&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Spring&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>团队的合作通过<code>import</code>来实现 .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource&#x3D;&quot;&#123;path&#125;&#x2F;beans.xml&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://blog.kuangstudy.com/index.php/archives/518/" target="_blank" rel="noopener">Spring：第一个程序、对象创建方式、配置说明</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> XML配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除Mathtype中Inline公式后的空格</title>
      <link href="/2020/01/09/%E5%88%A0%E9%99%A4Mathtype%E4%B8%ADInline%E5%85%AC%E5%BC%8F%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/01/09/%E5%88%A0%E9%99%A4Mathtype%E4%B8%ADInline%E5%85%AC%E5%BC%8F%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>1.开始－运行－regedit</p><p>2.HKEY_CURRENT_USER\Software\Design Science\DSMT6\WordCommands\</p><p>3.增加字符串NoSpaceAfterInline（注意，如果WordCommands分支不存在，请手动建立！）</p><p>4.将NoSpaceAfterInline－值设置为1－退出</p><p>5.运行office程序，输入公式，你会发现，公式后面的空格已经不存在了</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathtype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WORD中隐藏Mathtype的章节标记</title>
      <link href="/2020/01/09/WORD%E4%B8%AD%E9%9A%90%E8%97%8FMathtype%E7%9A%84%E7%AB%A0%E8%8A%82%E6%A0%87%E8%AE%B0/"/>
      <url>/2020/01/09/WORD%E4%B8%AD%E9%9A%90%E8%97%8FMathtype%E7%9A%84%E7%AB%A0%E8%8A%82%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Word中隐藏Mathtype的章节标记Equation-Chapter-Next-Section-1"><a href="#Word中隐藏Mathtype的章节标记Equation-Chapter-Next-Section-1" class="headerlink" title="Word中隐藏Mathtype的章节标记Equation Chapter (Next) Section 1"></a>Word中隐藏Mathtype的章节标记Equation Chapter (Next) Section 1</h1><p>具体操作步骤如下：</p><p>1.Word的“开始”菜单——“样式”，出现文档中使用的样式。<br>2.找到MTEquationSection，点右边下拉箭头“修改样式”（或者选中章节号域代码会自动跳到相应的样式）。<br>3.在弹出的“修改样式”对话框中，点左下角的“格式”按钮，选“字体”。<br>4.在“字体”对话框中把“隐藏”勾上，设置完成。</p><p><img src="https://i.loli.net/2020/01/09/I5KdOSqE9ygZhCP.png" alt="20200109153130.png"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathtype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2019/12/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/12/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul><li>共进行<code>n-1</code>轮排序</li><li>每一轮排序又是一个循环，循环规则如下：<blockquote><p>1.先假定当前数是最小数<br>2.然后和后面的每个数作比较，如果发现有比当前数更小的数就重新确定最小数，并得到下标<br>3.当遍历到数组的最后是，就得到本轮的最小数和下标<br>4.进行交换</p></blockquote></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class SelectSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;101,34,119,1&#125;;</span><br><span class="line">        System.out.println(&quot;排序前的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        </span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(&quot;排序后的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;选择排序</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex &#x3D; i;</span><br><span class="line">            int min &#x3D; arr[i];</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (min &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; arr[j];</span><br><span class="line">                    minIndex &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;将最小值与arr[i]进行交换</span><br><span class="line">            if (minIndex !&#x3D; i) &#123;</span><br><span class="line">                arr[minIndex] &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前的数组</span><br><span class="line">[101, 34, 119, 1]</span><br><span class="line">排序后的数组</span><br><span class="line">[1, 34, 101, 119]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2019/12/12/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/12/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul><li>共进行<code>n-1</code>次大循环</li><li>每一次的排序次数逐渐减少</li><li>如果发现在某次排序中没有发生一次交换，可以使用flag提前结束冒泡排序</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; &#123;3,9,-1,10,20&#125;;</span><br><span class="line">        System.out.println(&quot;排序前的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        </span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(&quot;排序后的数组&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        boolean flag &#x3D; false;  &#x2F;&#x2F;标识变量，表示是否交换</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;  &#x2F;&#x2F;共进行 arr.length - 1 次大循环</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;  &#x2F;&#x2F;在每次循环中的最大数交换至末尾</span><br><span class="line">                &#x2F;&#x2F;如果前面的数比后面的数大，则交换</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    flag &#x3D; true;</span><br><span class="line">                    temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;&#x2F;&#x2F;在一次排序中，一次交换都没有发生过</span><br><span class="line">                break;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                flag &#x3D; false;&#x2F;&#x2F;重置flag，进行下次判断</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前的数组</span><br><span class="line">[3, 9, -1, 10, 20]</span><br><span class="line">排序后的数组</span><br><span class="line">[-1, 3, 9, 10, 20]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的继承、重载与重写</title>
      <link href="/2019/09/12/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/"/>
      <url>/2019/09/12/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>子类通过关键字<code>extends</code>关键字继承父类</li><li>子类可以调用父类中的属性与方法（<code>public</code>、<code>protected</code>）</li><li>子类可以添加自己的独有成员</li><li>子类继承了父类的方法，但不能满足子类需要，方法可以重写</li></ul><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><ul><li>子类修饰符权限可以大于等于父类</li><li>父类用<code>final</code>修饰，子类不能重写；父类用<code>static</code>修饰，子类不存在重写；父类用<code>abstract</code>修饰，子类必须重写</li><li>子类返回值类型小于等于父类</li><li>子类方法名与父类一致</li></ul><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><ul><li>方法名字相同，参数列表不同</li><li>参数不同体现在类型、个数、顺序不同</li><li>返回值类型可随意，不能以返回类型作为重载函数的区分标准</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中异常捕获时的返回值问题</title>
      <link href="/2019/09/03/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/03/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="try-catch-finally-return"><a href="#try-catch-finally-return" class="headerlink" title="try{}catch(){}finally{}return;"></a>try{}catch(){}finally{}return;</h1><p>该情况语句后顺序执行。（不考虑异常）</p><h1 id="try-return-catch-finally-return"><a href="#try-return-catch-finally-return" class="headerlink" title="try{return;}catch(){}finally{}return;"></a>try{return;}catch(){}finally{}return;</h1><p>该情况执行完try语句块，将return的值保存在临时栈中，再执行finally语句块，之后返回临时栈中的值。</p><h1 id="try-catch-return-finally-return"><a href="#try-catch-return-finally-return" class="headerlink" title="try{}catch(){return;}finally{}return;"></a>try{}catch(){return;}finally{}return;</h1><p>无异常：执行try，执行finally，再执行return;<br>有异常：执行完catch语句块，将return的值保存在临时栈中，再执行finally语句块，之后返回临时栈中的值。</p><a id="more"></a><h1 id="try-catch-finally-return-1"><a href="#try-catch-finally-return-1" class="headerlink" title="try{}catch(){}finally{return;}"></a>try{}catch(){}finally{return;}</h1><p>执行finally中的return语句。</p><h1 id="try-return-catch-finally-return-1"><a href="#try-return-catch-finally-return-1" class="headerlink" title="try{return;}catch(){}finally{return;}"></a>try{return;}catch(){}finally{return;}</h1><p>执行完try语句块，将return的值保存在临时栈中，再执行finally语句块，因为finally中有return,所以返回finally中的return值。</p><h1 id="try-catch-return-finally-return-1"><a href="#try-catch-return-finally-return-1" class="headerlink" title="try{}catch(){return;}finally{return;}"></a>try{}catch(){return;}finally{return;}</h1><p>执行完catch语句块，将return的值保存在临时栈中，再执行finally语句块，因为finally中有return,所以返回finally中的return值。</p><h1 id="try-return-catch-return-finally-return"><a href="#try-return-catch-return-finally-return" class="headerlink" title="try{return;}catch(){return;}finally{return;}"></a>try{return;}catch(){return;}finally{return;}</h1><p>无异常：执行完try语句块，将return的值保存在临时栈中，再执行finally语句块，因为finally中有return,所以返回finally中的return值。<br>有异常：执行完catch语句块，将return的值保存在临时栈中，再执行finally语句块，因为finally中有return,所以返回finally中的</p><p><strong>总结</strong>：在正常情况（即程序正常执行try catch finally语句块，不会在语句中出现退出程序、线程终止等特殊情况）下，都会执行finally语句块，如果finally中有return,则程序会走finally中的return，如果没有，则先执行try或者catch中的return,将其存入临时栈中，执行完finally语句后才返回临时栈中的值。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类和集合类笔记</title>
      <link href="/2019/08/31/String%E7%B1%BB%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/31/String%E7%B1%BB%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>所属java.lang包，没有继承类，默认继承Object</p><h1 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h1><blockquote><p>Serializable<br>CharSequence<br>Comparable&lt;&gt;</p></blockquote><a id="more"></a><h1 id="String类构造方法"><a href="#String类构造方法" class="headerlink" title="String类构造方法"></a>String类构造方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;abc&quot;;</span><br><span class="line">String str &#x3D; new String();</span><br><span class="line">String str &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">String str &#x3D; new String(byte[] value);</span><br><span class="line">String str &#x3D; new String(char[] value);</span><br></pre></td></tr></table></figure><h1 id="String类的不可变性"><a href="#String类的不可变性" class="headerlink" title="String类的不可变性"></a>String类的不可变性</h1><p>体现在长度和内容不可变，因为String类中有<code>private final char[] value；</code>属性，长度不可变是由于数组的长度是固定的，用final修饰数组（引用地址不能改变）；内容不可变是由于private修饰的属性只能在本类中访问。</p><h1 id="String、StringBuffer与StringBuilder类的区别"><a href="#String、StringBuffer与StringBuilder类的区别" class="headerlink" title="String、StringBuffer与StringBuilder类的区别"></a>String、StringBuffer与StringBuilder类的区别</h1><p>1 String类的内容一旦声明后是不可改变的，改变的只是其内存的指向，而StringBuffer类的对象内容是可以改变的。<br>2 对于StringBuffer，不能像String那样直接通过赋值的方式完成对象实例化，必须通过构造方法的方式完成。<br>3 StringBuffer的在进行字符串处理时，不生成新的对象，在内存使用上要优于串类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入，删除等操作，使用StringBuffer要更加适合一些。<br>4 StringBuffer是早期1.0版本，线程同步，安全性高，效率低，StringBuilder是后来的1.5版本，线程非同步，安全性低，效率高。</p><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p><strong>无序</strong>原则：存放顺序与取出顺序不同<br><strong>无重复</strong>原则：都知道HashSet中不能存放重复元素，发现重复元素则拒绝存入，因此存储的是第一个元素，但是其内部是怎么保证元素不重复的呢？下面从源码去看看。<br>打开HashSet源码，发现其内部维护了一个HashMap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    static final long serialVersionUID &#x3D; -5024744406713321676L;</span><br><span class="line"></span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map</span><br><span class="line">    private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; instance has</span><br><span class="line">     * default initial capacity (16) and load factor (0.75).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet的构造方法其实就是在内部实例化了一个HashMap对象。其中还会看到一个static final的PRESENT变量，这个稍候再说，其实没什么实际用处。想知道为什么HashSet不能存放重复对象，那么第一步当然是看它的add方法怎么进行的判重，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，就把元素存放在了map里面。但是值得注意的是元素值作为的是map的key，map的value则是前面提到的PRESENT变量，这个变量只作为放入map时的一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：HashMap的key是不能重复的，而这里HashSet的元素又是作为了map的key，当然也不能重复了。</p><p>HashMap里面又是怎么保证key不重复的吧，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最关键的一句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k)))</span><br></pre></td></tr></table></figure><p>调用了对象的hashCode和equals方法进行的判断，所以又得出一个结论：若要将对象存放到HashSet中并保证对象不重复，<strong><em>应根据实际情况将对象的hashCode方法和equals方法进行重写</em></strong>。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>特点：<br>1 key存储的顺序与取得的顺序不同<br>2 不同的key可以存相同的value<br>3 key若相同，则将原有的value覆盖，而不是拒绝存入（与set相反）</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中==运算符与equals方法的比较</title>
      <link href="/2019/08/30/Java%E4%B8%AD-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2019/08/30/Java%E4%B8%AD-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>Java中测试两个变量是否相等有两种方式：一种是利用==运算符，另一种是利用equals()方法。<br>当使用==来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型（不一定要求数据类型严格相同），则只要两个变量的值相等，就返回true。但对于两个引用类型变量，只有它们<strong>指向同一个对象时</strong>，==判断才会返回true。==不可用于比较类型上没有父子关系的两个对象。</p><a id="more"></a><p>在举实际例子之前，我们先来区分一下String的<code>&quot;hello&quot;</code>字符串直接常量和<code>new String(&quot;hello&quot;)</code>。当java程序直接使用形如<code>&quot;hello&quot;</code>的字符串直接常量时,JVM将会使用常量池来管理这些字符串；当使用<code>new String(&quot;hello&quot;)</code>时，JVM会先使用常量池来管理<code>&quot;hello&quot;</code>直接量，再调用String类的构造器来创建一个新的String对象，新的对象将会被保存在堆内存中，换句话说，<code>new String(&quot;hello&quot;)</code>一共产生了两个字符串。<br><strong>例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1&#x3D;new String(&quot;abc&quot;);</span><br><span class="line">        String str2&#x3D;&quot;abc&quot;;</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序的输出结果为false。<br>因为java首先在栈里面生成了一个str1的地址然后指向堆里面的字符串“abc”，之后在常量池中会出现一个字符串“abc”，运行到下一行时str2会直接指向常量池中的字符串“abc”，所以str1和str2的地址不相等，故运行结果为false。<br>equals()方法是Object类提供的一个实例方法，因此所有的引用变量都可以使用，但这个方法判断两个对象是否相等的标准与==<strong>相同</strong>，同样要求引用变量指向同一个对象才会返回true,因此Object类里面的equals()方法没什么用处，我们现在用来比较字符串内容的equals()方法是String类里面<strong>重写</strong>的。String类里面重写的equals()方法比较的是对象里面的内容，只要内容相同，就返回true，但需要特别注意的是，equals()只能比较引用数据类型，不能比较基本数据类型。<br><strong>例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">        String str2&#x3D;new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(str1.equals(str2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序运行结果为true，因为equals()比较的是str1和str2的内容。<br><strong>例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">        String str2&#x3D;&quot;abc&quot;;</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的程序运行结果也为true，这是因为你直接赋值时java会先去常量池里面找有没有字符串”abc”，如果有，直接指向常量池里面的字符串”abc”，如果没有，在常量池里面会生成一个字符串”abc”。所以无论最终你声明了多少个直接量”abc”都会指向同一个字符串，此时地址相同，==的结果为true。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八皇后问题</title>
      <link href="/2019/07/16/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/16/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="八皇后问题算法思路分析"><a href="#八皇后问题算法思路分析" class="headerlink" title="八皇后问题算法思路分析"></a>八皇后问题算法思路分析</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>1.第一个皇后先放到第一行第一列。<br>2.第二个皇后放在第二行第一列，然后判断是否可行，如果不可行，继续放在第二列、第三列、依次把所有列都放完，找到一个合适的位置。<br>3.继续放第三个皇后，还是第一列、第二列……直到第八个皇后也能放到一个不冲突的位置，算找到了一个正确解。<br>4.当得到一个正确解时，就会开始回溯，即将第一个皇后放到第一列的所有正确解全部得到。<br>5.然后回头继续第一个皇后放到第二列，后面继续循环执行1、2、3、4的步骤。</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">ppackage com.atguigu.recursion;</span><br><span class="line"></span><br><span class="line">public class Queue8 &#123;</span><br><span class="line">    &#x2F;&#x2F;定义一个max表示共有多少个皇后</span><br><span class="line">    int max &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F;定义数组array保存皇后放置位置的结果，比如：arr[8]&#x3D;&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int array[] &#x3D; new int[max];</span><br><span class="line">    static int count &#x3D; 0;</span><br><span class="line">    static int judgecount &#x3D; 0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue8 queue8 &#x3D; new Queue8();</span><br><span class="line">        queue8.check(0);</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">        System.out.printf(&quot;共有%d种解法！&quot;,count);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(&quot;判断是否冲突的次数为%d次！&quot;,judgecount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;编写一个方法，放置第n个皇后</span><br><span class="line">    private void check(int n) &#123;</span><br><span class="line">        if(n &#x3D;&#x3D; max) &#123;&#x2F;&#x2F;n &#x3D; 8 ，表示8个皇后已经放好</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;依次放入并判断是否冲突</span><br><span class="line">        for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;先把当前皇后n放到该行的第一列</span><br><span class="line">            array[n] &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F;当放置第n个皇后到第i列时是否冲突</span><br><span class="line">            if(judge(n)) &#123;&#x2F;&#x2F;不冲突</span><br><span class="line">                &#x2F;&#x2F;接着放第n+1个皇后，开始递归</span><br><span class="line">                check(n+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;查看当放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span><br><span class="line">    private boolean judge(int n) &#123;&#x2F;&#x2F;n表示放第n个皇后</span><br><span class="line">        judgecount++;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;array[i] &#x3D;&#x3D; array[n]表示判断第n个皇后是否和前面n-1个皇后在同一列</span><br><span class="line">            &#x2F;&#x2F;Math.abs(array[n] - array[i]) &#x3D;&#x3D; Math.abs(n - i)表示判断第n个皇后是否和前面i个皇后在同一斜线</span><br><span class="line">            if(array[i] &#x3D;&#x3D; array[n]  || Math.abs(array[n] - array[i]) &#x3D;&#x3D; Math.abs(n - i)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;写一个方法，可以将皇后摆放的位置输出</span><br><span class="line">    private void print() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果显示"><a href="#结果显示" class="headerlink" title="结果显示"></a>结果显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">0 4 7 5 2 6 1 3 </span><br><span class="line">0 5 7 2 6 3 1 4 </span><br><span class="line">0 6 3 5 7 1 4 2 </span><br><span class="line">0 6 4 7 1 3 5 2 </span><br><span class="line">1 3 5 7 2 0 6 4 </span><br><span class="line">1 4 6 0 2 7 5 3 </span><br><span class="line">1 4 6 3 0 7 5 2 </span><br><span class="line">1 5 0 6 3 7 2 4 </span><br><span class="line">1 5 7 2 0 3 6 4 </span><br><span class="line">1 6 2 5 7 4 0 3 </span><br><span class="line">1 6 4 7 0 3 5 2 </span><br><span class="line">1 7 5 0 2 4 6 3 </span><br><span class="line">2 0 6 4 7 1 3 5 </span><br><span class="line">2 4 1 7 0 6 3 5 </span><br><span class="line">2 4 1 7 5 3 6 0 </span><br><span class="line">2 4 6 0 3 1 7 5 </span><br><span class="line">2 4 7 3 0 6 1 5 </span><br><span class="line">2 5 1 4 7 0 6 3 </span><br><span class="line">2 5 1 6 0 3 7 4 </span><br><span class="line">2 5 1 6 4 0 7 3 </span><br><span class="line">2 5 3 0 7 4 6 1 </span><br><span class="line">2 5 3 1 7 4 6 0 </span><br><span class="line">2 5 7 0 3 6 4 1 </span><br><span class="line">2 5 7 0 4 6 1 3 </span><br><span class="line">2 5 7 1 3 0 6 4 </span><br><span class="line">2 6 1 7 4 0 3 5 </span><br><span class="line">2 6 1 7 5 3 0 4 </span><br><span class="line">2 7 3 6 0 5 1 4 </span><br><span class="line">3 0 4 7 1 6 2 5 </span><br><span class="line">3 0 4 7 5 2 6 1 </span><br><span class="line">3 1 4 7 5 0 2 6 </span><br><span class="line">3 1 6 2 5 7 0 4 </span><br><span class="line">3 1 6 2 5 7 4 0 </span><br><span class="line">3 1 6 4 0 7 5 2 </span><br><span class="line">3 1 7 4 6 0 2 5 </span><br><span class="line">3 1 7 5 0 2 4 6 </span><br><span class="line">3 5 0 4 1 7 2 6 </span><br><span class="line">3 5 7 1 6 0 2 4 </span><br><span class="line">3 5 7 2 0 6 4 1 </span><br><span class="line">3 6 0 7 4 1 5 2 </span><br><span class="line">3 6 2 7 1 4 0 5 </span><br><span class="line">3 6 4 1 5 0 2 7 </span><br><span class="line">3 6 4 2 0 5 7 1 </span><br><span class="line">3 7 0 2 5 1 6 4 </span><br><span class="line">3 7 0 4 6 1 5 2 </span><br><span class="line">3 7 4 2 0 6 1 5 </span><br><span class="line">4 0 3 5 7 1 6 2 </span><br><span class="line">4 0 7 3 1 6 2 5 </span><br><span class="line">4 0 7 5 2 6 1 3 </span><br><span class="line">4 1 3 5 7 2 0 6 </span><br><span class="line">4 1 3 6 2 7 5 0 </span><br><span class="line">4 1 5 0 6 3 7 2 </span><br><span class="line">4 1 7 0 3 6 2 5 </span><br><span class="line">4 2 0 5 7 1 3 6 </span><br><span class="line">4 2 0 6 1 7 5 3 </span><br><span class="line">4 2 7 3 6 0 5 1 </span><br><span class="line">4 6 0 2 7 5 3 1 </span><br><span class="line">4 6 0 3 1 7 5 2 </span><br><span class="line">4 6 1 3 7 0 2 5 </span><br><span class="line">4 6 1 5 2 0 3 7 </span><br><span class="line">4 6 1 5 2 0 7 3 </span><br><span class="line">4 6 3 0 2 7 5 1 </span><br><span class="line">4 7 3 0 2 5 1 6 </span><br><span class="line">4 7 3 0 6 1 5 2 </span><br><span class="line">5 0 4 1 7 2 6 3 </span><br><span class="line">5 1 6 0 2 4 7 3 </span><br><span class="line">5 1 6 0 3 7 4 2 </span><br><span class="line">5 2 0 6 4 7 1 3 </span><br><span class="line">5 2 0 7 3 1 6 4 </span><br><span class="line">5 2 0 7 4 1 3 6 </span><br><span class="line">5 2 4 6 0 3 1 7 </span><br><span class="line">5 2 4 7 0 3 1 6 </span><br><span class="line">5 2 6 1 3 7 0 4 </span><br><span class="line">5 2 6 1 7 4 0 3 </span><br><span class="line">5 2 6 3 0 7 1 4 </span><br><span class="line">5 3 0 4 7 1 6 2 </span><br><span class="line">5 3 1 7 4 6 0 2 </span><br><span class="line">5 3 6 0 2 4 1 7 </span><br><span class="line">5 3 6 0 7 1 4 2 </span><br><span class="line">5 7 1 3 0 6 4 2 </span><br><span class="line">6 0 2 7 5 3 1 4 </span><br><span class="line">6 1 3 0 7 4 2 5 </span><br><span class="line">6 1 5 2 0 3 7 4 </span><br><span class="line">6 2 0 5 7 4 1 3 </span><br><span class="line">6 2 7 1 4 0 5 3 </span><br><span class="line">6 3 1 4 7 0 2 5 </span><br><span class="line">6 3 1 7 5 0 2 4 </span><br><span class="line">6 4 2 0 5 7 1 3 </span><br><span class="line">7 1 3 0 6 4 2 5 </span><br><span class="line">7 1 4 2 0 6 3 5 </span><br><span class="line">7 2 0 5 1 4 6 3 </span><br><span class="line">7 3 0 2 5 1 6 4 </span><br><span class="line">----------------</span><br><span class="line">共有92种解法！</span><br><span class="line">判断是否冲突的次数为15720次！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀、中缀、后缀表达式式</title>
      <link href="/2019/07/06/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%8F/"/>
      <url>/2019/07/06/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h1><p>操作符在操作数的前面，比如 $$+-5\ 4\ 3$$</p><h2 id="前缀表达式的计算机求值"><a href="#前缀表达式的计算机求值" class="headerlink" title="前缀表达式的计算机求值"></a>前缀表达式的计算机求值</h2><p>从右至左扫描表达式，遇到数字时，将数字压入栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的运算（栈顶元素和次顶元素），并将结果入栈，重复上述过程直到表达式最左端，最后运算得出的值即表达式的结果。</p><p><strong>例如</strong>：$$(3+4)\times5-6$$对应的前缀表达式为$$-\times+3\ 4\ 5\ 6$$，针对前缀表达式求值步骤如下：<br>1.<strong>从右至左</strong>扫描，将6，5，4，3，压入栈；<br>2.遇到$$+$$运算符，弹出3和4(3为栈顶元素为次顶元素），计算出$$3+4=7$$的值，再将7入栈；<br>3.接下来是$$\times$$运算符，弹出7和5，计算出$$7\times5=35$$，将35入栈；<br>4.最后时$$-$$运算符，计算出$$35-6=29$$，得出最终结果。</p><a id="more"></a><h1 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h1><p>操作符在操作数的中间，这也是人类最容易识别的算术表达式$$3+4-5$$</p><h1 id="后缀表达式（逆波兰表达式）"><a href="#后缀表达式（逆波兰表达式）" class="headerlink" title="后缀表达式（逆波兰表达式）"></a>后缀表达式（逆波兰表达式）</h1><p>操作符在操作数的后面，比如$$3\ 4+5-$$</p><h2 id="后缀表达式的计算机求值"><a href="#后缀表达式的计算机求值" class="headerlink" title="后缀表达式的计算机求值"></a>后缀表达式的计算机求值</h2><p>从左至右扫描表达式，遇到数字时，将数字压入栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的运算（次顶元素和栈顶元素），并将结果入栈，重复上述过程直到表达式最右端，最后运算得出的值即表达式的结果。</p><p><strong>例如</strong>：$$(3+4)\times5-6$$对应的前缀表达式为$$3\ 4+5\times6-$$，针对前缀表达式求值步骤如下：</p><p>1.<strong>从左至右</strong>扫描，将3和4压入栈；<br>2.遇到$$+$$运算符，弹出4和3(4为栈顶元素3为次顶元素），计算出$$3+4=7$$的值，再将7入栈；<br>3.将5入栈；<br>4.接下来是$$\times$$运算符，弹出5和7，计算出$$7\times5=35$$，将35入栈；<br>5.将6入栈；<br>6.最后时$$-$$运算符，计算出$$35-6=29$$，得出最终结果。</p><h1 id="中缀表达式转为后缀表达式"><a href="#中缀表达式转为后缀表达式" class="headerlink" title="中缀表达式转为后缀表达式"></a>中缀表达式转为后缀表达式</h1><p>1.初始化两个栈：运算符栈s1储存中间结果的栈s2；<br>2.从左至右扫描中缀表达式；<br>3.遇到操作数时，将其压入s2；<br>4.遇到运算符时，比较其与s1栈顶运算的优先级：<br>（1）如果s1为空，或栈顶运算符为左括号“<code>(</code>”，则直接将此运算符入栈；<br>（2）否则，若优先级比栈顶运算符高，也将运算符压入s1；<br>（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.(1)，与s1中新的栈顶运算符相比较。<br>5.遇到括号是：<br>（1）如果是左括号“<code>(</code>”，则直接压入s1；<br>（2）如果是右括号“<code>)</code>”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃；<br>6.重复2~5，直到表达式的最右端；<br>7.将s1中剩余的运算符依次弹出并压入s2；<br>8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。</p><p><strong>示例</strong>：<br>将中缀表达式$$1+((2+3)\times4)-5$$转换为后缀表达式，步骤如下：</p><table><thead><tr><th>扫描到的元素</th><th>s2(栈底-&gt;栈顶)</th><th>s1(栈底-&gt;栈顶)</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>空</td><td>数字直接入栈</td></tr><tr><td>+</td><td>1</td><td>+</td><td>s1为空，运算符直接入栈</td></tr><tr><td>(</td><td>1</td><td>+(</td><td>左括号直接入栈</td></tr><tr><td>(</td><td>1</td><td>+((</td><td>同上</td></tr><tr><td>2</td><td>1 2</td><td>+((</td><td>数字</td></tr><tr><td>+</td><td>1 2</td><td>+((+</td><td>s1栈顶为左括号运算符直接入栈</td></tr><tr><td>3</td><td>1 2 3</td><td>+((+</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 +</td><td>+(</td><td>右括号弹出运算符直到遇到左括号</td></tr><tr><td>$$\times$$</td><td>1 2 3 +</td><td>+($$\times$$</td><td>s1栈顶为左括号运算符直接入栈</td></tr><tr><td>4</td><td>1 2 3 + 4</td><td>+($$\times$$</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 + 4 $$\times$$</td><td>+</td><td>右括号弹出运算符直到遇到左括号</td></tr><tr><td>-</td><td>1 2 3 + 4 $$\times$$ +</td><td>-</td><td>-与+优先级相同先弹出+再压入-</td></tr><tr><td>5</td><td>1 2 3 + 4 $$\times$$ + 5</td><td>-</td><td>数字</td></tr><tr><td>到达最右端</td><td>1 2 3 + 4 $$\times$$ + 5 -</td><td>空</td><td>s1中剩余的运算符</td></tr></tbody></table><h2 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成中缀表达式转后缀表达式的功能</span><br><span class="line">&#x2F;&#x2F;说明</span><br><span class="line">&#x2F;&#x2F;1.1+((2+3)*4)-5  -&gt;  1 2 3 + 4 * + 5 -</span><br><span class="line">&#x2F;&#x2F;2.因为直接对字符串进行操作不方便，因此先将字符串转成中缀表达式对应的List</span><br><span class="line">&#x2F;&#x2F;  即“1+((2+3)*4)-5”  &#x3D;&gt;  ArrayList[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]</span><br><span class="line">&#x2F;&#x2F;3.将得到的中缀表达式对应的List  &#x3D;&gt;  后缀表达式对应的List</span><br><span class="line">&#x2F;&#x2F;  即ArrayList[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]  &#x3D;&gt;  ArrayList[1, 2, 3, +, 4, *, +, 5, -]</span><br><span class="line">Scanner s &#x3D; new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入需要计算的表达式~~&quot;);</span><br><span class="line">String expression &#x3D; s.next();&#x2F;&#x2F;当输入为&quot;1+((2+3)*4)-5&quot;时，结果为16</span><br><span class="line">s.close();</span><br><span class="line">List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(expression);</span><br><span class="line">System.out.println(&quot;对应的中缀表达式:&quot; + infixExpressionList);</span><br><span class="line">List&lt;String&gt; suffixExpressionList &#x3D; parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">System.out.println(&quot;对应的后缀表达式:&quot; + suffixExpressionList);</span><br><span class="line">System.out.printf(&quot;表达式 %s &#x3D; %d&quot;,expression,calculate(suffixExpressionList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法：将中缀表达式转成对应的List</span><br><span class="line">public static List&lt;String&gt; toInfixExpressionList(String s)&#123;</span><br><span class="line">&#x2F;&#x2F;定义一个List，存放中缀表达式对应的内容</span><br><span class="line">List&lt;String&gt; ls &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">int i &#x3D; 0;&#x2F;&#x2F;用于遍历中缀表达式字符串</span><br><span class="line">String str;&#x2F;&#x2F;对多位数进行拼接</span><br><span class="line">char c;&#x2F;&#x2F;每遍历到一个字符就放入到c中</span><br><span class="line">do &#123;</span><br><span class="line">&#x2F;&#x2F;如果c是一个非数字，就需要加入到ls中</span><br><span class="line">if((c &#x3D; s.charAt(i)) &lt; 48 || (c &#x3D; s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">ls.add(&quot;&quot; + c);</span><br><span class="line">i++;</span><br><span class="line">&#125;else &#123;&#x2F;&#x2F;如果是一个数，需要考虑多位数的问题</span><br><span class="line">str &#x3D; &quot;&quot;;&#x2F;&#x2F;先将str置成空串</span><br><span class="line">while(i &lt; s.length() &amp;&amp; (c &#x3D; s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c &#x3D; s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str); </span><br><span class="line">&#125;</span><br><span class="line">&#125;while(i &lt; s.length());</span><br><span class="line">return ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将得到的中缀表达式对应的List  &#x3D;&gt;  后缀表达式对应的List</span><br><span class="line">public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls)&#123;</span><br><span class="line">&#x2F;&#x2F;定义两个栈</span><br><span class="line">Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;();&#x2F;&#x2F;符号栈</span><br><span class="line">List&lt;String&gt; s2 &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;存储中间结果的栈</span><br><span class="line">&#x2F;&#x2F;遍历ls</span><br><span class="line">for (String item : ls) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是一个数，加入到s2</span><br><span class="line">if(item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125;else if(item.equals(&quot;(&quot;)) &#123;&#x2F;&#x2F;如果是左括号“(”，则直接压入s1</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;else if(item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">while(!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();&#x2F;&#x2F;将“(”弹出s1</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符，则将s1栈顶的运算符弹出并加入到s2中，再次转到4.(1)，与s1中新的栈顶运算符相比较</span><br><span class="line">while(s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;&#x3D; Operation.getValue(item)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;还需要将item压入栈</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入s2</span><br><span class="line">while(s1.size() !&#x3D; 0) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">return s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成对逆波兰表达式的运算</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 1.从左至右扫描，将3和4压入栈；</span><br><span class="line"> * 2.遇到+运算符，弹出4和3(4为栈顶元素3为次顶元素），计算出3+4&#x3D;7的值，再将7入栈；</span><br><span class="line"> * 3.将5入栈；</span><br><span class="line"> * 4.接下来是运算符，弹出5和7，计算出7×5&#x3D;35，将35入栈；</span><br><span class="line"> * 5.将6入栈；</span><br><span class="line"> * 6.最后时-运算符，计算出35-6&#x3D;29，得出最终结果。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F;创建一个栈</span><br><span class="line">Stack&lt;String&gt; stack &#x3D; new Stack&lt;String&gt;();</span><br><span class="line">&#x2F;&#x2F;遍历ls</span><br><span class="line">for(String item: ls) &#123;</span><br><span class="line">&#x2F;&#x2F;使用正则表达式来取出数</span><br><span class="line">if(item.matches(&quot;\\d+&quot;)) &#123;&#x2F;&#x2F;代表匹配多位数</span><br><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">stack.push(item);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;pop出两个数并运算，再入栈</span><br><span class="line">int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">if(item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 + num2;</span><br><span class="line">&#125;else if(item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 - num2;</span><br><span class="line">&#125;else if(item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 * num2;</span><br><span class="line">&#125;else if(item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 &#x2F; num2;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">throw new RuntimeException(&quot;运算符有误~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将res入栈</span><br><span class="line">stack.push(&quot;&quot; + res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后留在stack中的数据是运算结果</span><br><span class="line">return Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编写一个类Operation,可以返回一个运算符对应的优先级</span><br><span class="line">class Operation&#123;</span><br><span class="line">private static int ADD &#x3D; 1;</span><br><span class="line">private static int SUB &#x3D; 1;</span><br><span class="line">private static int MUL &#x3D; 2;</span><br><span class="line">private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写一个方法，返回对应的优先级数字</span><br><span class="line">public static int getValue(String operation) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">switch (operation) &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">result &#x3D; ADD;</span><br><span class="line">break;</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">result &#x3D; SUB;</span><br><span class="line">break;</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">result &#x3D; MUL;</span><br><span class="line">break;</span><br><span class="line">case &quot;&#x2F;&quot;:</span><br><span class="line">result &#x3D; DIV;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return result; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用栈实现计算器</title>
      <link href="/2019/07/05/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2019/07/05/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>使用栈完成表达式计算的思路</p><ul><li>1.通过一个index（索引），来遍历我们的表达式，使用数据栈和符号栈分别存放数据和符号；</li><li>2.如果发现是一个数字就直接入栈；</li><li>3.如果扫描到一个符号，分为如下情况：<br>（1）如果发现当前的符号栈为空，直接入栈；<br>（2）如果符号栈有操作符，就进行比较，如果当前的操作符优先级小于或等于栈中的操作符，<br>  就需要从数据栈中pop出两个数，从符号栈中pop出一个符号，进行运算，将得到的结果入数据栈，<br>  然后将当前的操作符入符号栈，如果当前的操作符优先级大于栈中的操作符就直接入符号栈；</li><li>4.当表达式扫描完毕，就顺序的从数据栈和符号栈中pop出相应的数据和符号，并运算；</li><li>5.最后数据栈中只有一个数据，就是表达式的结果。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用栈完成表达式计算的思路</span><br><span class="line"> * 1.通过一个index（索引），来遍历我们的表达式，使用数据栈和符号栈分别存放数据和符号</span><br><span class="line"> * 2.如果发现是一个数字就直接入栈</span><br><span class="line"> * 3.如果扫描到一个符号，分为如下情况</span><br><span class="line"> * （1）如果发现当前的符号栈为空，直接入栈</span><br><span class="line"> * （2）如果符号栈有操作符，就进行比较，如果当前的操作符优先级小于或等于栈中的操作符，</span><br><span class="line"> *     就需要从数据栈中pop出两个数，从符号栈中pop出一个符号，进行运算，将得到的结</span><br><span class="line"> *     果入数据栈，然后将当前的操作符入符号栈，如果当前的操作符优先级大于栈中的操作符</span><br><span class="line"> *     就直接入符号栈</span><br><span class="line"> * 4.当表达式扫描完毕，就顺序的从数据栈和符号栈中pop出相应的数据和符号，并运算</span><br><span class="line"> * 5.最后数据栈中只有一个数据，就是表达式的结果。</span><br><span class="line"> * @author Bill</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Calulator &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String expression &#x3D; &quot;&quot;;</span><br><span class="line">System.out.println(&quot;请输入所要计算的表达式~~&quot;);</span><br><span class="line">Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">expression &#x3D; scanner.next();</span><br><span class="line">scanner.close();</span><br><span class="line">&#x2F;&#x2F;创建两个栈，一个数据栈，一个符号栈</span><br><span class="line">ArrayStack2 numStack &#x3D; new ArrayStack2(10);</span><br><span class="line">ArrayStack2 operStack &#x3D; new ArrayStack2(10);</span><br><span class="line">&#x2F;&#x2F;定义需要的相关变量</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">int num1 &#x3D; 0;</span><br><span class="line">int num2 &#x3D; 0;</span><br><span class="line">int oper &#x3D; 0;</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">char ch &#x3D; &#39; &#39;;&#x2F;&#x2F;将每次扫描的char保存到ch</span><br><span class="line">String keepNum &#x3D; &quot;&quot;;&#x2F;&#x2F;用于拼接多位数</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;一次得到表达式的每一个字符</span><br><span class="line">ch &#x3D; expression.substring(index, index + 1).charAt(0);</span><br><span class="line">&#x2F;&#x2F;判断</span><br><span class="line">if(operStack.isOper(ch)) &#123;&#x2F;&#x2F;如果是运算符</span><br><span class="line">&#x2F;&#x2F;判断当前的符号栈是否为空</span><br><span class="line">if(!operStack.isEmpty()) &#123;</span><br><span class="line">if(operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek())) &#123;</span><br><span class="line">num1 &#x3D; numStack.pop();</span><br><span class="line">num2 &#x3D; numStack.pop();</span><br><span class="line">oper &#x3D; operStack.pop();</span><br><span class="line">res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">numStack.push(res);</span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;如果为空直接入符号栈</span><br><span class="line">operStack.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;如果是数时，需要向expression表达式的后再看一位，如果是数就进行扫描，如果是符号才入栈</span><br><span class="line">&#x2F;&#x2F;需要定义一个字符串变量，用于拼接多位数</span><br><span class="line">keepNum +&#x3D; ch;</span><br><span class="line">&#x2F;&#x2F;如果ch是表达式的最后一位，就直接入栈</span><br><span class="line">if(index &#x3D;&#x3D; expression.length() - 1) &#123;</span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;判断下一个字符是否为数字，如果是数字就继续扫描，如果是运算符，则入数据栈</span><br><span class="line">if(operStack.isOper(expression.substring(index+1, index+2).charAt(0))) &#123;</span><br><span class="line">numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">&#x2F;&#x2F;keepNum需要清空</span><br><span class="line">keepNum &#x3D; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br><span class="line">&#x2F;&#x2F;判断是否扫描结束</span><br><span class="line">if(index &gt;&#x3D; expression.length()) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当表达式扫描完毕，就顺序的从数据栈和符号栈中pop出相应的数据和符号，并运算</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;如佛符号栈为空，则计算到最后的结果，数据栈中只有一个数字</span><br><span class="line">if(operStack.isEmpty()) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">num1 &#x3D; numStack.pop();</span><br><span class="line">num2 &#x3D; numStack.pop();</span><br><span class="line">oper &#x3D; operStack.pop();</span><br><span class="line">res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">numStack.push(res);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将数据栈的最后一个数据pop出来就是所求结果</span><br><span class="line">int res2 &#x3D; numStack.pop();</span><br><span class="line">System.out.printf(&quot;%s &#x3D; %d&quot;,expression,res2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个类，表示栈</span><br><span class="line">class ArrayStack2&#123;</span><br><span class="line">private int maxSize;&#x2F;&#x2F;栈的大小</span><br><span class="line">private int[] stack;&#x2F;&#x2F;用于储存栈的数据</span><br><span class="line">private int top &#x3D; -1;</span><br><span class="line">public ArrayStack2(int maxSize) &#123;</span><br><span class="line">this.maxSize &#x3D; maxSize;</span><br><span class="line">stack &#x3D; new int[this.maxSize];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回当前栈顶值</span><br><span class="line">public int peek() &#123;</span><br><span class="line">return stack[top];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;栈满</span><br><span class="line">public boolean isFull() &#123;</span><br><span class="line">return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;栈空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top &#x3D;&#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;先判断是否满</span><br><span class="line">if(isFull()) &#123;</span><br><span class="line">System.out.println(&quot;栈已满~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">public int pop() &#123;</span><br><span class="line">&#x2F;&#x2F;判断是否空</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;抛出异常</span><br><span class="line">throw new RuntimeException(&quot;栈为空，没有数据~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int value &#x3D; stack[top];</span><br><span class="line">top--;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历栈,从栈顶开始显示</span><br><span class="line">public void list() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;栈为空，没有数据~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;,i,stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回运算符的优先级，返回值越大，优先级越高</span><br><span class="line">public int priority(int oper) &#123;</span><br><span class="line">if(oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;else if(oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return -1;&#x2F;&#x2F;假定目前的表达式只有+，-，*，&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断是否为运算符</span><br><span class="line">public boolean isOper(char val) &#123;</span><br><span class="line">return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39;|| val &#x3D;&#x3D; &#39;*&#39;|| val &#x3D;&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算方法</span><br><span class="line">public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">int res &#x3D; 0;&#x2F;&#x2F;用于存放计算结果</span><br><span class="line">switch (oper) &#123;</span><br><span class="line">case &#39;+&#39;:</span><br><span class="line">res &#x3D; num1 + num2;</span><br><span class="line">break;</span><br><span class="line">case &#39;-&#39;:</span><br><span class="line">res &#x3D; num2 - num1;</span><br><span class="line">break;</span><br><span class="line">case &#39;*&#39;:</span><br><span class="line">res &#x3D; num1 * num2;</span><br><span class="line">break;</span><br><span class="line">case &#39;&#x2F;&#39;:</span><br><span class="line">res &#x3D; num2 &#x2F; num1;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用数组模拟栈</title>
      <link href="/2019/07/04/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88/"/>
      <url>/2019/07/04/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package stack;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用数组模拟栈</span><br><span class="line"> * 定义一个pop表示栈顶，初始化为-1</span><br><span class="line"> * 入栈操作，当有数据加入时，top++，stack[top]&#x3D;data;</span><br><span class="line"> * 出栈操作，int value &#x3D; stack[top],top--,return value;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ArrayStack stack &#x3D; new ArrayStack(4);</span><br><span class="line">String key &#x3D; &quot;&quot;;</span><br><span class="line">boolean loop &#x3D; true;</span><br><span class="line">Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">while(loop) &#123;</span><br><span class="line">System.out.println(&quot;show:显示栈&quot;);</span><br><span class="line">System.out.println(&quot;exit:退出程序&quot;);</span><br><span class="line">System.out.println(&quot;push:添加数据到栈（入栈）&quot;);</span><br><span class="line">System.out.println(&quot;pop:从栈中取出数据（出栈）&quot;);</span><br><span class="line">System.out.println(&quot;请输入你的选择~~&quot;);</span><br><span class="line">key &#x3D; scanner.next();</span><br><span class="line">switch (key) &#123;</span><br><span class="line">case &quot;show&quot;:</span><br><span class="line">stack.list();</span><br><span class="line">break;</span><br><span class="line">case &quot;push&quot;:</span><br><span class="line">System.out.println(&quot;请输入一个数据~~&quot;);</span><br><span class="line">int value &#x3D; scanner.nextInt();</span><br><span class="line">stack.push(value);</span><br><span class="line">break;</span><br><span class="line">case &quot;pop&quot;:</span><br><span class="line">try &#123;</span><br><span class="line">int res &#x3D; stack.pop();</span><br><span class="line">System.out.printf(&quot;出栈的数据是%d\n&quot;,res);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case &quot;exit&quot;:</span><br><span class="line">scanner.close();</span><br><span class="line">loop &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建一个类，表示栈</span><br><span class="line">class ArrayStack&#123;</span><br><span class="line">private int maxSize;&#x2F;&#x2F;栈的大小</span><br><span class="line">private int[] stack;&#x2F;&#x2F;用于储存栈的数据</span><br><span class="line">private int top &#x3D; -1;</span><br><span class="line">public ArrayStack(int maxSize) &#123;</span><br><span class="line">this.maxSize &#x3D; maxSize;</span><br><span class="line">stack &#x3D; new int[this.maxSize];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;栈满</span><br><span class="line">public boolean isFull() &#123;</span><br><span class="line">return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;栈空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return top &#x3D;&#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;先判断是否满</span><br><span class="line">if(isFull()) &#123;</span><br><span class="line">System.out.println(&quot;栈已满~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;出栈</span><br><span class="line">public int pop() &#123;</span><br><span class="line">&#x2F;&#x2F;判断是否空</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;抛出异常</span><br><span class="line">throw new RuntimeException(&quot;栈为空，没有数据~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int value &#x3D; stack[top];</span><br><span class="line">top--;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历栈,从栈顶开始显示</span><br><span class="line">public void list() &#123;</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;栈为空，没有数据~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;,i,stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Josephu问题（环形链表）</title>
      <link href="/2019/07/04/Josephu%E9%97%AE%E9%A2%98%EF%BC%88%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
      <url>/2019/07/04/Josephu%E9%97%AE%E9%A2%98%EF%BC%88%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>设标号为1，2，……，n的n个人围成一圈，约定从标号为k(1&lt;k&lt;n)的人开始从1报数，数到m的那个人出列，下一位又从1开始报数，数到m的人又出列，以此类推，直到所有人出列为止，求由此产生的一个出队标号序列。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.linkedlist;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 问题描述：</span><br><span class="line"> * 设标号为1，2，……，n的n个人围成一圈，约定从标号为k(1&lt;k&lt;n)的人开始从1报数，数到m的那个人出列，</span><br><span class="line"> * 下一位又从1开始报数，数到m的人又出列，以此类推，直到所有人出列为止，求由此产生的一个出队标号序列</span><br><span class="line"> * @author Bill</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Josephu &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">CircleSingleLinkedList circleSingleLinkedList &#x3D; new CircleSingleLinkedList();</span><br><span class="line">circleSingleLinkedList.addBoy(5);&#x2F;&#x2F;加入5个小孩节点</span><br><span class="line">System.out.println(&quot;显示小孩~~&quot;);</span><br><span class="line">circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">System.out.println(&quot;共5人，从1号开始，数到2出列的顺序为~~&quot;);</span><br><span class="line">circleSingleLinkedList.countBoy(1, 2, 5);&#x2F;&#x2F;2-&gt;4-&gt;1-&gt;5-&gt;3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建一个环形的单向链表</span><br><span class="line">class CircleSingleLinkedList&#123;</span><br><span class="line">&#x2F;&#x2F;创建一个first节点，当前没有编号</span><br><span class="line">private Boy first &#x3D; new Boy(-1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加Boy节点，构建环形链表</span><br><span class="line">public void addBoy(int nums) &#123;&#x2F;&#x2F;nums表示加入节点的个数</span><br><span class="line">&#x2F;&#x2F;对nums做数据校验</span><br><span class="line">if(nums &lt; 1) &#123;</span><br><span class="line">System.out.println(&quot;nums的值不正确&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Boy curBoy &#x3D; null;&#x2F;&#x2F;辅助指针，帮助创建环形链表</span><br><span class="line">&#x2F;&#x2F;使用for创建环形链表</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; nums; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;根据编号，创建节点</span><br><span class="line">Boy boy &#x3D; new Boy(i);</span><br><span class="line">&#x2F;&#x2F;如果是第一个</span><br><span class="line">if(i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">first &#x3D; boy;</span><br><span class="line">first.setNext(first);&#x2F;&#x2F;构成环形</span><br><span class="line">curBoy &#x3D; first;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">curBoy.setNext(boy);</span><br><span class="line">boy.setNext(first);</span><br><span class="line">curBoy &#x3D; boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历当前环形链表</span><br><span class="line">public void showBoy() &#123;</span><br><span class="line">&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">if(first &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表未空~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;因为first不能动，使用辅助指针完成遍历</span><br><span class="line">Boy curBoy &#x3D; first;</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.printf(&quot;%d号小孩\n&quot;,curBoy.getNo());</span><br><span class="line">if(curBoy.getNext() &#x3D;&#x3D; first) &#123;&#x2F;&#x2F;是否到达最后</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">curBoy &#x3D; curBoy.getNext();&#x2F;&#x2F;后移</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;根据用户的输入，计算出出圈的顺序</span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param startNo表示从第几个小孩开始报数</span><br><span class="line"> * @param countNo表示报数几次</span><br><span class="line"> * @param nums表示最开始有多少小孩在圈中</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public void countBoy(int startNo, int countNo, int nums) &#123;</span><br><span class="line">&#x2F;&#x2F;先对数据做校验</span><br><span class="line">if(first &#x3D;&#x3D; null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">System.out.println(&quot;参数输入有误，请重新输入~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建辅助指针，帮助完成小孩出圈</span><br><span class="line">Boy helper &#x3D; first;</span><br><span class="line">&#x2F;&#x2F;事先应该指向环形链表的最后节点</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(helper.getNext() &#x3D;&#x3D; first) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">helper &#x3D; helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;先让first helper移动startNo - 1次</span><br><span class="line">for(int j &#x3D; 0; j &lt; startNo - 1; j++) &#123;</span><br><span class="line">first &#x3D; first.getNext();</span><br><span class="line">helper &#x3D; helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(helper &#x3D;&#x3D; first) &#123;&#x2F;&#x2F;说明圈中只有一个节点</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;让first helper同时移动countNo - 1次</span><br><span class="line">for(int j &#x3D;0;j &lt; countNo - 1; j++) &#123;</span><br><span class="line">first &#x3D; first.getNext();</span><br><span class="line">helper &#x3D; helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这时first指向的小孩出圈</span><br><span class="line">System.out.printf(&quot;小孩%d出圈\n&quot;,first.getNo());</span><br><span class="line">&#x2F;&#x2F;将first指向的节点删除</span><br><span class="line">first &#x3D; first.getNext();</span><br><span class="line">helper.setNext(first); </span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(&quot;最后留在圈中的小孩编号为%d\n&quot;,first.getNo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个 BOY类，表示一个节点</span><br><span class="line">class Boy&#123;</span><br><span class="line">private int no;</span><br><span class="line">private Boy next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">public Boy (int no) &#123;</span><br><span class="line">this.no &#x3D; no;</span><br><span class="line">&#125;</span><br><span class="line">public int getNo() &#123;</span><br><span class="line">return no;</span><br><span class="line">&#125;</span><br><span class="line">public void setNo(int no) &#123;</span><br><span class="line">this.no &#x3D; no;</span><br><span class="line">&#125;</span><br><span class="line">public Boy getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line">public void setNext(Boy next) &#123;</span><br><span class="line">this.next &#x3D; next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">显示小孩~~</span><br><span class="line">1号小孩</span><br><span class="line">2号小孩</span><br><span class="line">3号小孩</span><br><span class="line">4号小孩</span><br><span class="line">5号小孩</span><br><span class="line">----------------------------</span><br><span class="line">共5人，从1号开始，数到2出列的顺序为~~</span><br><span class="line">小孩2出圈</span><br><span class="line">小孩4出圈</span><br><span class="line">小孩1出圈</span><br><span class="line">小孩5出圈</span><br><span class="line">最后留在圈中的小孩编号为3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2019/07/04/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/04/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; 测试</span><br><span class="line">System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">&#x2F;&#x2F;创建节点,new 后按快捷键“ctrl+1”补全</span><br><span class="line">HeroNode2 hero1 &#x3D; new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">HeroNode2 hero2 &#x3D; new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">HeroNode2 hero3 &#x3D; new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">HeroNode2 hero4 &#x3D; new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个双向链表对象</span><br><span class="line">DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">&#x2F;&#x2F;doubleLinkedList.add(hero4);</span><br><span class="line">&#x2F;&#x2F;doubleLinkedList.add(hero3);</span><br><span class="line">&#x2F;&#x2F;doubleLinkedList.add(hero1);</span><br><span class="line">&#x2F;&#x2F;doubleLinkedList.add(hero2);</span><br><span class="line"></span><br><span class="line">doubleLinkedList.addByOrder(hero3);</span><br><span class="line">doubleLinkedList.addByOrder(hero2);</span><br><span class="line">doubleLinkedList.addByOrder(hero1);</span><br><span class="line">doubleLinkedList.addByOrder(hero4);</span><br><span class="line">doubleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改测试</span><br><span class="line">HeroNode2 newHeroNode &#x3D; new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">doubleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除测试 </span><br><span class="line">doubleLinkedList.del(5);</span><br><span class="line">doubleLinkedList.del(3);</span><br><span class="line">System.out.println(&quot;删除后的链表情况&quot;);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList&#123;</span><br><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">private HeroNode2 head &#x3D; new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">public HeroNode2 getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历打印双向链表</span><br><span class="line">public void list() &#123;</span><br><span class="line">&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;因为头节点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">HeroNode2 temp &#x3D; head.next;</span><br><span class="line">while(true)&#123;</span><br><span class="line">&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">if(temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出节点的信息</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#x2F;&#x2F;将next后移</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加一个节点到双向链表的最后</span><br><span class="line">public void add(HeroNode2 heroNode) &#123;</span><br><span class="line">&#x2F;&#x2F;因为head节点不能动，因此需要一个辅助变量temp</span><br><span class="line">HeroNode2 temp &#x3D; head;</span><br><span class="line">&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">while (true) &#123;</span><br><span class="line">&#x2F;&#x2F;找到链表的最后</span><br><span class="line">if(temp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果没有找到，将temp后移</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当退出循环时，temp指向链表的最后</span><br><span class="line">temp.next &#x3D; heroNode;</span><br><span class="line">heroNode.pre &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;按编号顺序添加节点</span><br><span class="line">public void addByOrder(HeroNode2 heroNode) &#123;</span><br><span class="line">&#x2F;&#x2F;头节点不能动，用辅助变量来找到添加的位置</span><br><span class="line">HeroNode2 temp &#x3D; head;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;标志添加的编号是否存在，默认为false</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;说明temp在链表的最后</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(temp.next.no &gt; heroNode.no) &#123;&#x2F;&#x2F;位置找到，就在temp后插入</span><br><span class="line">break;</span><br><span class="line">&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no) &#123;&#x2F;&#x2F;说明希望添加的heroNode的编号存在</span><br><span class="line">flag &#x3D; true;&#x2F;&#x2F;说明编号存在</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;&#x2F;&#x2F;temp后移，遍历当前链表</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断flag的值</span><br><span class="line">if(flag) &#123;</span><br><span class="line">System.out.printf(&quot;准备插入到列表的%d号英雄已经存在，不能插入~~\n&quot;,heroNode.no);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;插入到链表中，temp的后面</span><br><span class="line">&#x2F;&#x2F;heroNode.next &#x3D; temp.next;</span><br><span class="line">&#x2F;&#x2F;heroNode.pre &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;temp.next &#x3D; heroNode;</span><br><span class="line">heroNode.next &#x3D; temp.next;</span><br><span class="line">if(temp.next!&#x3D;null) &#123;</span><br><span class="line">temp.next.pre &#x3D; heroNode;</span><br><span class="line">&#125;</span><br><span class="line">heroNode.pre &#x3D; temp;</span><br><span class="line">temp.next &#x3D; heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;修改一个节点的内容</span><br><span class="line">public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode2 temp &#x3D; head.next;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;代表是否找到</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;&#x2F;&#x2F;表示链表遍历完成，到达链表尾部</span><br><span class="line">&#125;</span><br><span class="line">if(temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">flag &#x3D; true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">temp.name &#x3D; newHeroNode.name;</span><br><span class="line">temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.printf(&quot;没有找到编号为%d的节点&quot;,newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除一个节点</span><br><span class="line">&#x2F;&#x2F;对于双向链表可以找到要删除的节点，自我删除即可</span><br><span class="line">public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断当前链表是否为空</span><br><span class="line">if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表为空，无法删除~~&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode2 temp &#x3D; head.next;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到待删除的节点</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;已经到链表的尾部</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(temp.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">flag &#x3D; true;&#x2F;&#x2F;找到待删除节点</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">temp.pre.next &#x3D; temp.next; </span><br><span class="line">&#x2F;&#x2F;如果是最后一个节点就不需要执行下面这句话，否则会出现空指针异常</span><br><span class="line">if(temp.next !&#x3D; null) &#123;</span><br><span class="line">temp.next.pre &#x3D; temp.pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.printf(&quot;要删除的节点%d不存在\n&quot;,no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义HeroNode2类，每个HeroNode2对象就是一个节点</span><br><span class="line">class HeroNode2&#123;</span><br><span class="line">public int no;</span><br><span class="line">public String name;</span><br><span class="line">public String nickname;</span><br><span class="line">public HeroNode2 next;&#x2F;&#x2F;指向下个节点</span><br><span class="line">public HeroNode2 pre;</span><br><span class="line"></span><br><span class="line">public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">this.no &#x3D; no;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.nickname &#x3D; nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为了显示方便，我们重写toString：快捷键alt+shift+s，点击Generate toString()...</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickname&#x3D;&quot; + nickname + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">双向链表的测试</span><br><span class="line">准备插入到列表的3号英雄已经存在，不能插入~~</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;卢俊义, nickname&#x3D;玉麒麟]</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;林冲, nickname&#x3D;豹子头]</span><br><span class="line">修改后的链表情况</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;卢俊义, nickname&#x3D;玉麒麟]</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;公孙胜, nickname&#x3D;入云龙]</span><br><span class="line">要删除的节点5不存在</span><br><span class="line">删除后的链表情况</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;卢俊义, nickname&#x3D;玉麒麟]</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;公孙胜, nickname&#x3D;入云龙]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写与重载的区别</title>
      <link href="/2019/06/17/%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/06/17/%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><p>从字面上看，重写就是<strong>重新写一遍</strong>的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在<strong>方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写</strong>，这就是重写。但要注意<strong><em>子类函数的访问修饰权限不能少于父类的</em></strong>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub </span><br><span class="line">Son s &#x3D; new Son(); </span><br><span class="line">s.sayHello(); </span><br><span class="line">&#125; </span><br><span class="line">public void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;Hello&quot;);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">class Son extends Father&#123; </span><br><span class="line">@Override public void sayHello() &#123;</span><br><span class="line"> &#x2F;&#x2F; TODO Auto-generated method stub </span><br><span class="line"> System.out.println(&quot;hello by &quot;); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发生在父类与子类之间。</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同。</li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)。</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。</li></ul><h1 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h1><p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub </span><br><span class="line">Father s &#x3D; new Father(); </span><br><span class="line">s.sayHello(); </span><br><span class="line">s.sayHello(&quot;wintershii&quot;); </span><br><span class="line">&#125; </span><br><span class="line">public void sayHello() &#123; </span><br><span class="line">System.out.println(&quot;Hello&quot;); </span><br><span class="line">&#125; </span><br><span class="line">public void sayHello(String name) &#123; </span><br><span class="line">System.out.println(&quot;Hello&quot; + &quot; &quot; + name); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重载Overload是一个类中多态性的一种表现。</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)。</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</li></ul><h1 id="方法的重载和重写的区别"><a href="#方法的重载和重写的区别" class="headerlink" title="方法的重载和重写的区别"></a>方法的重载和重写的区别</h1><blockquote><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解static关键字</title>
      <link href="/2019/06/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/06/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="静态修饰符static"><a href="#静态修饰符static" class="headerlink" title="静态修饰符static"></a>静态修饰符static</h1><ul><li>成员变量：类中定义的属性变量。</li><li>局部变量：方法中定义的变量。</li><li>static可修饰成员变量和成员方法。</li><li>static修饰的成员变量可通过对象和类调用（调用的是同一个）。</li><li>修饰成员变量表示静态变量，是所有对象公用的，在内存中值占有一份内存。</li><li>修饰成员方法表示静态方法，只能直接访问静态变量，可通过对象访问非静态变量。</li><li>随着类的加载而加载，优先于对象存在。</li></ul><a id="more"></a><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="StaticDemo1"><a href="#StaticDemo1" class="headerlink" title="StaticDemo1"></a>StaticDemo1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class StaticDemo1&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person p1 &#x3D; new Person(&quot;Bill&quot;,25);</span><br><span class="line">p1.country &#x3D; &quot;中国&quot;;</span><br><span class="line"></span><br><span class="line">Person p2 &#x3D; new Person(&quot;Jack&quot;,27);</span><br><span class="line">p2.country &#x3D; &quot;美国&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(p1.name +&quot; &quot;+p1.age +&quot; &quot;+p1.country);</span><br><span class="line">System.out.println(p2.name +&quot; &quot;+p2.age +&quot; &quot;+p2.country);</span><br><span class="line">System.out.println(p1.name +&quot; &quot;+p1.age +&quot; &quot;+Person.country);&#x2F;&#x2F;可通过对象和类调用（调用的是同一个）</span><br><span class="line">&#x2F;&#x2F;country是所有对象公用的，只有一份，因此p1.country,p2.country,Person.country均为“美国”。</span><br><span class="line"></span><br><span class="line">Person.show(p1);</span><br><span class="line">Person.show(p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">public static String country;</span><br><span class="line">public String name;</span><br><span class="line">public int age;</span><br><span class="line">public Person(String name,int age)&#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;静态方法不能直接访问非静态变量</span><br><span class="line">public static void show(Person p)&#123;</span><br><span class="line">System.out.println(p.name +&quot; &quot;+p.age +&quot; &quot;+country);&#x2F;&#x2F;静态方法只能通过对象访问非静态变量，可直接访问静态变量</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bill 25 美国</span><br><span class="line">Jack 27 美国</span><br><span class="line">Bill 25 美国</span><br><span class="line">Bill 25 美国</span><br><span class="line">Jack 27 美国</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/08/5cfb519a7298a62965.png" alt="201807232103340.png"></p><h2 id="StaticDemo2"><a href="#StaticDemo2" class="headerlink" title="StaticDemo2"></a>StaticDemo2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class StaticDemo2&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Circle c1 &#x3D; new Circle();</span><br><span class="line">c1.radius &#x3D; 2;</span><br><span class="line">System.out.println(c1.getPerimeter());</span><br><span class="line"></span><br><span class="line">Circle c2 &#x3D; new Circle();</span><br><span class="line">c2.radius &#x3D; 4;</span><br><span class="line">System.out.println(c2.getPerimeter());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle&#123;</span><br><span class="line">&#x2F;&#x2F;将pi声明为静态变量（对Circle类的所有对象pi &#x3D; 3.141592653f），可以节省内存空间</span><br><span class="line">public static float pi &#x3D; 3.141592653f;</span><br><span class="line">public float radius;</span><br><span class="line"></span><br><span class="line">public float getPerimeter()&#123;</span><br><span class="line">return (2*pi*radius);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/06/05/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/06/05/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>以节点的方式存储数据。</li><li>每个节点包含data域，用于存储数据，包含next域，用于指向下个节点。</li><li>链表的各个节点不一定是连续存放。</li><li>链表分带头节点的链表和不带头节点的链表。</li></ul><a id="more"></a><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;创建节点,new 后按快捷键“ctrl+1”补全</span><br><span class="line">HeroNode hero1 &#x3D; new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">HeroNode hero2 &#x3D; new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">HeroNode hero3 &#x3D; new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">HeroNode hero4 &#x3D; new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个链表</span><br><span class="line">SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">&#x2F;&#x2F;加入</span><br><span class="line">&#x2F;&#x2F;singleLinkedList.add(hero1);</span><br><span class="line">&#x2F;&#x2F;singleLinkedList.add(hero2);</span><br><span class="line">&#x2F;&#x2F;singleLinkedList.add(hero3);</span><br><span class="line">&#x2F;&#x2F;singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按编号顺序加入</span><br><span class="line">singleLinkedList.addByOrder(hero1);</span><br><span class="line">singleLinkedList.addByOrder(hero4);</span><br><span class="line">singleLinkedList.addByOrder(hero2);</span><br><span class="line">singleLinkedList.addByOrder(hero3);</span><br><span class="line">singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试反转</span><br><span class="line">reverseList(singleLinkedList.getHead());</span><br><span class="line">System.out.println(&quot;反转后的单链表~~&quot;);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试修改节点的代码</span><br><span class="line">HeroNode newHeroNode &#x3D; new HeroNode(2, &quot;小卢&quot;,&quot;玉麒麟 ~~&quot;);</span><br><span class="line">singleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(&quot;修改后的链表情况~~&quot;);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除一个节点</span><br><span class="line">singleLinkedList.del(1);</span><br><span class="line">singleLinkedList.del(4);</span><br><span class="line">System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取链表有效长度</span><br><span class="line">System.out.printf(&quot;链表中有效节点的个数为%d个&quot;,getLength(singleLinkedList.getHead()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算有效节点个数</span><br><span class="line">public static int getLength(HeroNode head) &#123;</span><br><span class="line">if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int length &#x3D; 0;</span><br><span class="line">HeroNode cur &#x3D; head.next;</span><br><span class="line">while(cur!&#x3D;null) &#123;</span><br><span class="line">length++;</span><br><span class="line">cur &#x3D; cur.next;</span><br><span class="line">&#125;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将单链表反转</span><br><span class="line">public static void reverseList(HeroNode head) &#123;</span><br><span class="line">&#x2F;&#x2F;如果当前链表为空或只有一个节点，则无需反转，直接返回</span><br><span class="line">if(head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义一个辅助的指针变量，帮助我们遍历原来的链表</span><br><span class="line">HeroNode cur &#x3D; head.next;</span><br><span class="line">HeroNode next &#x3D; null;&#x2F;&#x2F;用来指向当前节点的下一个节点</span><br><span class="line">HeroNode reverseHead &#x3D; new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;遍历原来的链表，每遍历一个节点就将其取出，并放在心链表reverseHead的最前端</span><br><span class="line">while(cur !&#x3D; null) &#123;</span><br><span class="line">next &#x3D; cur.next;&#x2F;&#x2F;暂时保存当前节点的下一个节点</span><br><span class="line">cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下个节点指向新链表的最前端，第一次时reverseHead.next为空</span><br><span class="line">reverseHead.next &#x3D; cur;&#x2F;&#x2F;新链表指向cur</span><br><span class="line">cur &#x3D; next;&#x2F;&#x2F;cur后移</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将head.next指向reverseHead.next,实现单链表的反转</span><br><span class="line">head.next &#x3D; reverseHead.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList管理英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">&#x2F;&#x2F;先初始化一个头节点，头节点不能动,不存放具体数据</span><br><span class="line">private HeroNode head &#x3D; new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">public HeroNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(HeroNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">&#x2F;&#x2F;思路：当不考虑编号顺序时</span><br><span class="line">&#x2F;&#x2F;1.找到当前链表的最后节点</span><br><span class="line">&#x2F;&#x2F;2.将最后节点的next指向新的节点</span><br><span class="line">public void add(HeroNode heroNode) &#123;</span><br><span class="line">&#x2F;&#x2F;因为head节点不能动，因此需要一个辅助变量temp</span><br><span class="line">HeroNode temp &#x3D; head;</span><br><span class="line">&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">while (true) &#123;</span><br><span class="line">&#x2F;&#x2F;找到链表的最后</span><br><span class="line">if(temp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果没有找到，将temp后移</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当退出循环时，temp指向链表的最后</span><br><span class="line">&#x2F;&#x2F;将最后节点的next指向新的节点</span><br><span class="line">temp.next &#x3D; heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种添加英雄的方式，根据排名将英雄插入到指定位置</span><br><span class="line">&#x2F;&#x2F;如果有排名则添加失败，并给出提示</span><br><span class="line">public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">&#x2F;&#x2F;头节点不能动，用辅助变量来找到添加的位置</span><br><span class="line">&#x2F;&#x2F;因为是单链表，所以temp是添加位置的前一个节点，否则不能添加</span><br><span class="line">HeroNode temp &#x3D; head;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;标志添加的编号是否存在，默认为false</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;说明temp在链表的最后</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(temp.next.no &gt; heroNode.no) &#123;&#x2F;&#x2F;位置找到，就在temp后插入</span><br><span class="line">break;</span><br><span class="line">&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no) &#123;&#x2F;&#x2F;说明希望添加的heroNode的编号存在</span><br><span class="line">flag &#x3D; true;&#x2F;&#x2F;说明编号存在</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;&#x2F;&#x2F;temp后移，遍历当前链表</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断flag的值</span><br><span class="line">if(flag) &#123;</span><br><span class="line">System.out.printf(&quot;准备插入到列表的%d号英雄已经存在，不能插入~~\n&quot;,heroNode.no);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;插入到链表中，temp的后面</span><br><span class="line">heroNode.next &#x3D; temp.next;</span><br><span class="line">temp.next &#x3D; heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;修改节点的信息，根据no编号修改，即no编号不变</span><br><span class="line">public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">HeroNode temp &#x3D; head.next;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;代表是否找到</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;&#x2F;&#x2F;表示链表遍历完成，到达链表尾部</span><br><span class="line">&#125;</span><br><span class="line">if(temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">flag &#x3D; true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">temp.name &#x3D; newHeroNode.name;</span><br><span class="line">temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.printf(&quot;没有找到编号为%d的节点&quot;,newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除节点的代码</span><br><span class="line">&#x2F;&#x2F;思路：</span><br><span class="line">&#x2F;&#x2F;1.head不能动，设置一个temp辅助节点找到待删除节点带前一个节点</span><br><span class="line">&#x2F;&#x2F;2.当比较时，采用temp.next.no和需要删除节点的no比较</span><br><span class="line">&#x2F;&#x2F;3.temp.next &#x3D; temp.next.next; </span><br><span class="line">public void del(int no) &#123;</span><br><span class="line">HeroNode temp &#x3D; head;</span><br><span class="line">boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到待删除的节点</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(temp.next&#x3D;&#x3D;null) &#123;&#x2F;&#x2F;已经到链表的尾部</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(temp.next.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">flag &#x3D; true;&#x2F;&#x2F;找到待删除节点的前一个节点</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">temp.next &#x3D; temp.next.next; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.printf(&quot;要删除的节点%d不存在&quot;,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示链表【遍历】</span><br><span class="line">public void list() &#123;</span><br><span class="line">&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;链表为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;因为头节点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">HeroNode temp &#x3D; head.next;</span><br><span class="line">while(true)&#123;</span><br><span class="line">&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">if(temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出节点的信息</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#x2F;&#x2F;将next后移</span><br><span class="line">temp &#x3D; temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode类，每个HeroNode对象就是一个节点</span><br><span class="line">class HeroNode&#123;</span><br><span class="line">public int no;</span><br><span class="line">public String name;</span><br><span class="line">public String nickname;</span><br><span class="line">public HeroNode next;&#x2F;&#x2F;指向下个节点</span><br><span class="line"></span><br><span class="line">public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">this.no &#x3D; no;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.nickname &#x3D; nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为了显示方便，我们重写toString：快捷键alt+shift+s，点击Generate toString()...</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickname&#x3D;&quot; + nickname + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">准备插入到列表的3号英雄已经存在，不能插入~~</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;卢俊义, nickname&#x3D;玉麒麟]</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;林冲, nickname&#x3D;豹子头]</span><br><span class="line">反转后的单链表~~</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;林冲, nickname&#x3D;豹子头]</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;卢俊义, nickname&#x3D;玉麒麟]</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">修改后的链表情况~~</span><br><span class="line">HeroNode [no&#x3D;4, name&#x3D;林冲, nickname&#x3D;豹子头]</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;小卢, nickname&#x3D;玉麒麟 ~~]</span><br><span class="line">HeroNode [no&#x3D;1, name&#x3D;宋江, nickname&#x3D;及时雨]</span><br><span class="line">删除后的链表情况~~</span><br><span class="line">HeroNode [no&#x3D;3, name&#x3D;吴用, nickname&#x3D;智多星]</span><br><span class="line">HeroNode [no&#x3D;2, name&#x3D;小卢, nickname&#x3D;玉麒麟 ~~]</span><br><span class="line">链表中有效节点的个数为2个</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形队列（数组实现）</title>
      <link href="/2019/06/05/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/05/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h1><ul><li>含义：它是在写程序时候一种队列的特殊表达方式，把队列数据组中的最后一个元素和第一个元素相连构成环，所以称为环形队列。</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li><code>front</code>初始值为0，指向队列的第一个元素，也就是说<code>arr[front]</code>是队列的第一个元素。</li><li><code>rear</code>初始值为0，指向队列的最后一个元素的后一个位置。</li><li>当队列满时，条件是<code>(rear+1) % maxSize == front</code>。</li><li>当队列为空时，条件是<code>rear == front</code>。</li><li>队列中有效数据的个数为<code>(rear+maxSize-front) % maxSize</code>。</li></ul><a id="more"></a><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;测试数组模拟环形队列案例。。。&quot;);</span><br><span class="line">&#x2F;&#x2F; 创建一个队列</span><br><span class="line">CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;说明：设置为4 ，有效数据个数最大为3</span><br><span class="line">char key &#x3D; &#39; &#39;;&#x2F;&#x2F;接收用户输入</span><br><span class="line">Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">boolean loop &#x3D; true;</span><br><span class="line">&#x2F;&#x2F;输出一个菜单</span><br><span class="line">while(loop) &#123;</span><br><span class="line">System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">key &#x3D; scanner.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">switch (key) &#123;</span><br><span class="line">case &#39;s&#39;:</span><br><span class="line">queue.showQueue();</span><br><span class="line">break;</span><br><span class="line">case &#39;a&#39;:</span><br><span class="line">System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">int value &#x3D; scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line">break;</span><br><span class="line">case &#39;g&#39;:</span><br><span class="line">try &#123;</span><br><span class="line">int res &#x3D; queue.getQueue();</span><br><span class="line">System.out.printf(&quot;取出的数据是%d\n&quot;,res);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case &#39;h&#39;:</span><br><span class="line">try &#123;</span><br><span class="line">int res &#x3D; queue.headQueue();</span><br><span class="line">System.out.printf(&quot;队列头的数据是%d\n&quot;,res);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case &#39;e&#39;:</span><br><span class="line">scanner.close();</span><br><span class="line">loop &#x3D; false;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序退出&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CircleArray&#123;</span><br><span class="line">private int maxSize;&#x2F;&#x2F;表示数组的最大容量</span><br><span class="line">private int front;&#x2F;&#x2F;队列头:front初始值为0，指向队列的第一个元素，也就是说arr[front]是队列的第一个元素。</span><br><span class="line">private int rear;&#x2F;&#x2F;队列尾:rear初始值为0，指向队列的最后一个元素的后一个位置。</span><br><span class="line">private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列。</span><br><span class="line"></span><br><span class="line">public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">maxSize &#x3D; arrMaxSize;</span><br><span class="line">arr &#x3D; new int[maxSize];</span><br><span class="line">front &#x3D; 0;</span><br><span class="line">rear &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断队列是否满</span><br><span class="line">public boolean isFull() &#123;</span><br><span class="line">return (rear + 1) % maxSize &#x3D;&#x3D; front;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return rear &#x3D;&#x3D; front;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加数据到队列</span><br><span class="line">public void addQueue(int n) &#123;</span><br><span class="line">&#x2F;&#x2F;判断队列是否满</span><br><span class="line">if(isFull()) &#123;</span><br><span class="line">System.out.println(&quot;队列满，不能加入数据&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">arr[rear] &#x3D; n;&#x2F;&#x2F;直接将数据加入</span><br><span class="line">rear &#x3D; (rear+1)%maxSize;&#x2F;&#x2F;让rear后移,这里必须考虑取模</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取队列的数据，出队列</span><br><span class="line">public int getQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;通过抛出异常</span><br><span class="line">throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;front是指向队列的第一个元素</span><br><span class="line">&#x2F;&#x2F;1.先把front对应的值保存到一个临时变量</span><br><span class="line">&#x2F;&#x2F;2.将front后移,考虑取模,否则数组会越界</span><br><span class="line">&#x2F;&#x2F;3.将临时保存的变量返回</span><br><span class="line">int value &#x3D; arr[front];</span><br><span class="line">front &#x3D; (front + 1) % maxSize;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">public void showQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;遍历</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;队列空，没有数据&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;思路：从front开始遍历，遍历front + size()个元素</span><br><span class="line">for (int i &#x3D; front; i &lt; front + size(); i++) &#123;</span><br><span class="line">System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i % maxSize,arr[i % maxSize]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求出当前队列有效数据的个数</span><br><span class="line">public int size() &#123;</span><br><span class="line">return (rear+maxSize-front) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示队列头数据，注意不是取数据</span><br><span class="line">public int headQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;判断</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">throw new RuntimeException(&quot;队列空，没有数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return arr[front];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（数组实现）</title>
      <link href="/2019/06/04/%E9%98%9F%E5%88%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E9%98%9F%E5%88%97%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。可用于银行叫号系统中。。。</p><p><strong>特点</strong>：</p><ul><li>有序列表</li><li>先进先出</li><li>front初值为-1，随出队（删除）操作逐渐加1</li><li>rear初值为-1，随入队（插入）操作逐渐加1</li></ul><a id="more"></a><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><img src="https://i.loli.net/2019/06/04/5cf61968abe6090595.png" alt="队列数组实现.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.management.RuntimeErrorException;</span><br><span class="line"></span><br><span class="line">import com.sun.tools.javac.launcher.Main.Fault;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个队列</span><br><span class="line">ArrayQueue queue &#x3D; new ArrayQueue(3);</span><br><span class="line">char key &#x3D; &#39; &#39;;&#x2F;&#x2F;接收用户输入</span><br><span class="line">Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">boolean loop &#x3D; true;</span><br><span class="line">&#x2F;&#x2F;输出一个菜单</span><br><span class="line">while(loop) &#123;</span><br><span class="line">System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">key &#x3D; scanner.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">switch (key) &#123;</span><br><span class="line">case &#39;s&#39;:</span><br><span class="line">queue.showQueue();</span><br><span class="line">break;</span><br><span class="line">case &#39;a&#39;:</span><br><span class="line">System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">int value &#x3D; scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line">break;</span><br><span class="line">case &#39;g&#39;:</span><br><span class="line">try &#123;</span><br><span class="line">int res &#x3D; queue.getQueue();</span><br><span class="line">System.out.printf(&quot;取出的数据是%d\n&quot;,res);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case &#39;h&#39;:</span><br><span class="line">try &#123;</span><br><span class="line">int res &#x3D; queue.headQueue();</span><br><span class="line">System.out.printf(&quot;队列头的数据是%d\n&quot;,res);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case &#39;e&#39;:</span><br><span class="line">scanner.close();</span><br><span class="line">loop &#x3D; false;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序退出&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用数组模拟队列——编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">private int maxSize;&#x2F;&#x2F;表示数组的最大容量</span><br><span class="line">private int front;&#x2F;&#x2F;队列头</span><br><span class="line">private int rear;&#x2F;&#x2F;队列尾</span><br><span class="line">private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建队列的构造器</span><br><span class="line">public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">maxSize &#x3D; arrMaxSize;</span><br><span class="line">arr &#x3D; new int[maxSize];</span><br><span class="line">front &#x3D; -1;&#x2F;&#x2F;指向队列头的前一个位置</span><br><span class="line">rear &#x3D; -1;&#x2F;&#x2F;指向队列尾的具体数据（即队列的最后一个数据）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否满</span><br><span class="line">public boolean isFull() &#123;</span><br><span class="line">return rear &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return rear &#x3D;&#x3D; front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加数据到队列</span><br><span class="line">public void addQueue(int n) &#123;</span><br><span class="line">&#x2F;&#x2F;判断队列是否满</span><br><span class="line">if(isFull()) &#123;</span><br><span class="line">System.out.println(&quot;队列满，不能加入数据&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">rear++;&#x2F;&#x2F;让rear后移</span><br><span class="line">arr[rear] &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取队列的数据，出队列</span><br><span class="line">public int getQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;通过抛出异常</span><br><span class="line">throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line">front++;&#x2F;&#x2F;front后移</span><br><span class="line">return arr[front];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">public void showQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;遍历</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;队列空，没有数据&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示队列头数据，注意不是取数据</span><br><span class="line">public int headQueue() &#123;</span><br><span class="line">&#x2F;&#x2F;判断</span><br><span class="line">if(isEmpty()) &#123;</span><br><span class="line">throw new RuntimeException(&quot;队列空，没有数据&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return arr[front+1];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2019/06/04/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2019/06/04/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><ul><li>第一行：第一列表示原始数组行数，第二列表示原始数组列数，第三列表示原始数组有多少个有效数据</li><li>其余行：第一列表示有效数据行号，第二列表示有效数据列号，第一三列表示有效数据数据值</li></ul><p><strong>用途</strong>：当数组中大多数元素为0或者未使用时，可用稀疏数组以达到压缩数据的作用。</p><a id="more"></a><h1 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个原始的二维数组11*11</span><br><span class="line">&#x2F;&#x2F; 0：表示没有棋子，1：表示黑子，2：表示蓝子</span><br><span class="line">int chessArr1[][] &#x3D; new int [11][11];</span><br><span class="line">chessArr1[1][2] &#x3D; 1;</span><br><span class="line">chessArr1[2][3] &#x3D; 2;</span><br><span class="line">&#x2F;&#x2F;输出原始二维数组</span><br><span class="line">System.out.println(&quot;原始的二维数组~~~~&quot;);</span><br><span class="line">for(int[] row : chessArr1) &#123;</span><br><span class="line">for(int data:row) &#123;</span><br><span class="line">System.out.printf(&quot;%d\t&quot;,data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 稀疏数组（只有3列）：</span><br><span class="line"> * 第一行：第一列表示原始数组行数，第二列表示原始数组列数，第三列表示原始数组有多少个有效数据</span><br><span class="line"> * 其余行：第一列表示有效数据行号，第二列表示列号，第一三列表示数据值</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;将二维数组转为稀疏数组的思路</span><br><span class="line">&#x2F;&#x2F;1.先遍历二维数组得到非0数据的个数</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 11; i++) &#123;</span><br><span class="line">for(int j &#x3D; 0; j &lt; 11; j++) &#123;</span><br><span class="line">if(chessArr1[i][j]!&#x3D;0) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.创建对应的稀疏数组</span><br><span class="line">int sparseArr[][]&#x3D;new int[sum+1][3];</span><br><span class="line">&#x2F;&#x2F;给稀疏数组赋值</span><br><span class="line">sparseArr[0][0]&#x3D;11;</span><br><span class="line">sparseArr[0][1]&#x3D;11;</span><br><span class="line">sparseArr[0][2]&#x3D;sum;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历二维数组，将非0的值存放到稀疏数组中</span><br><span class="line">int count &#x3D; 0;&#x2F;&#x2F;用于记录是第几个非0数据</span><br><span class="line">for (int i &#x3D; 0; i &lt; 11; i++) &#123;</span><br><span class="line">for(int j &#x3D; 0; j &lt; 11; j++) &#123;</span><br><span class="line">if(chessArr1[i][j]!&#x3D;0) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][0] &#x3D; i;</span><br><span class="line">sparseArr[count][1] &#x3D; j;</span><br><span class="line">sparseArr[count][2] &#x3D; chessArr1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出稀疏数组的形式</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;得到的稀疏数组为~~~~&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; sparseArr.length;i++) &#123;</span><br><span class="line">System.out.printf(&quot;%d\t%d\t%d\t\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#x2F;&#x2F;将稀疏数组转为原始二维数组</span><br><span class="line">&#x2F;**思路：</span><br><span class="line"> * 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，</span><br><span class="line"> * 2.再读取稀疏数组的后几行数据，赋值给原始的二维数组即可。</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">int chessArr2[][] &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">for(int i &#x3D; 1;i &lt; sparseArr.length;i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;恢复后的二维数组~~~~&quot;);</span><br><span class="line">for(int[] row : chessArr2) &#123;</span><br><span class="line">for(int data:row) &#123;</span><br><span class="line">System.out.printf(&quot;%d\t&quot;,data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">原始的二维数组~~~~</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line"></span><br><span class="line">得到的稀疏数组为~~~~</span><br><span class="line">11112</span><br><span class="line">121</span><br><span class="line">232</span><br><span class="line"></span><br><span class="line">恢复后的二维数组~~~~</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br></pre></td></tr></table></figure><h1 id="Java中的for循环"><a href="#Java中的for循环" class="headerlink" title="Java中的for循环"></a>Java中的for循环</h1><blockquote><p>for (循环变量类型 循环变量名称 : 要被遍历的对象)  循环体</p></blockquote><p>遍历数组的简单方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 建立一个数组 *&#x2F;</span><br><span class="line">int[] integers &#x3D; &#123;1， 2， 3， 4&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 开始遍历 *&#x2F;</span><br><span class="line">for (int i : integers) &#123;</span><br><span class="line">    System.out.println(i); &#x2F;* 依次输出“1”、“2”、“3”、“4” *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所用的for循环，会在编译期间被看成是这样的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 建立一个数组 *&#x2F;</span><br><span class="line"> int[] integers &#x3D; &#123;1， 2， 3， 4&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 开始遍历 *&#x2F;</span><br><span class="line"> for (int i &#x3D; 0; i &lt; integers.length; i++) &#123;</span><br><span class="line">     System.out.println(integers[i]); &#x2F;* 依次输出“1”、“2”、“3”、“4” *&#x2F;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk12配置环境变量</title>
      <link href="/2019/06/01/jdk12%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2019/06/01/jdk12%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置JAVA-HOME"><a href="#配置JAVA-HOME" class="headerlink" title="配置JAVA_HOME"></a>配置JAVA_HOME</h1><ul><li>按<code>Windows键+R键</code>，出现运行窗口，在打开中输入<code>sysdm.cpl</code>，点击确定，出现”<code>系统属性</code>“窗口。</li><li>点击”<code>高级</code>“选项=&gt;点击”<code>环境变量</code>“，出现”<code>环境变量</code>“窗口，可以配置用户环境变量和系统环境变更，用户环境就是只对当前用户生效，系统环境是对所有用户生效。</li><li>根据需要，自己选择合适的，本文就是针对所有用户生效的，在点击”<code>系统环境变量</code>“ 下面 “<code>新建</code>“，变量名是<code>JAVA_HOME</code>，变量值是<code>jdk中bin</code>目录的上一级目录，点击”<code>确定</code>“。</li></ul><h1 id="配置Path环境变量"><a href="#配置Path环境变量" class="headerlink" title="配置Path环境变量"></a>配置Path环境变量</h1><ul><li><p>选中变量中”<code>Path</code>“然后点击”<code>编辑</code>“ 来编辑Path变量。</p><p>  把<code>%JAVA_HOME%\bin;</code>这个变量插入最前面，注意要有分号和后面的变量间隔开，然后点击<code>确定</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与派生</title>
      <link href="/2019/03/26/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
      <url>/2019/03/26/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>继承</strong>是面向对象程序设计中重要的特性。<br>继承主要是指在己有类的或称为<strong>基类</strong>的基础上创建新类的过程，这个新类就是<strong>派生类</strong>。<br>派生类自动的包含了基类的成员，包括所有的数据和操作，而且它还可以增加自身新的成员。<br>在C++中，一个派生类可以从一个基类派生，也可以从多个基类派生，从一个基类派生的称为单继承，一个派生类从两个或多个基类派生则称为多继承。<br>继承机制除了支持软件复用外，还具备以下三个作用：</p><ul><li>对事物进行分类。</li><li>支持软件的增量开发。</li><li>对概念进行组合。</li></ul><a id="more"></a><h1 id="在C-中类的继承关系可以用如下语法表示："><a href="#在C-中类的继承关系可以用如下语法表示：" class="headerlink" title="在C++中类的继承关系可以用如下语法表示："></a>在C++中类的继承关系可以用如下语法表示：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 派生类名: 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">  派生类成员声明</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，基类的构造函数和析构函数不能被派生类继承，派生类若要初始化基类的数据成员必须在构造函数中初始化。</p><p>例如：定义大学生类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123; </span><br><span class="line">private:</span><br><span class="line">int number;</span><br><span class="line">char name[20];</span><br><span class="line">public:</span><br><span class="line">Student()</span><br><span class="line">&#123;</span><br><span class="line">number&#x3D;0;</span><br><span class="line">name[0]&#x3D;’\0’;</span><br><span class="line">&#125;</span><br><span class="line">Void SetValue(int n,char *s1)</span><br><span class="line">&#123; </span><br><span class="line">number&#x3D;n;</span><br><span class="line">Strcpy(name,s1);</span><br><span class="line">&#125;</span><br><span class="line">void Print()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;”Number:”&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;”Name:”&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">class UGStudent:public Student</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int   age;</span><br><span class="line">int   grade;</span><br><span class="line">public:</span><br><span class="line">UGStudent ( )</span><br><span class="line">&#123;</span><br><span class="line">SetValue(0,””);</span><br><span class="line">age&#x3D;0;  grade&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">UGStudent (int n,char *s1,int a,int g)</span><br><span class="line">&#123;</span><br><span class="line">SetValue(n,s1);</span><br><span class="line">age&#x3D;a;  grade&#x3D;g;</span><br><span class="line">&#125;</span><br><span class="line">void PrintExtra()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;”Age:”&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;”Grade:”&lt;&lt;grade&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">UGStudent st1(100,”wang”,18,1);</span><br><span class="line">st1.Print();&#x2F;&#x2F;调用基类的函数</span><br><span class="line">st1.PrintExtra();&#x2F;&#x2F;调用派生类新定义的函数</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为:<br>Number:100<br>Name: wang<br>Age:18<br>Grade:1</p><h1 id="派生类的访问属性"><a href="#派生类的访问属性" class="headerlink" title="派生类的访问属性"></a>派生类的访问属性</h1><p>类的成员可以分为<code>public</code>（公有）、<code>protected</code>（保护）和<code>private</code>（私有）三种访问权限。<br>类的非静态成员函数可以访问类中的所有成员，但是通过类的“<code>对象.成员</code>”方式（在类的作用域之外），则只能访问该类的公有成员。<br>类的继承方式有公有继承（public）、保护继承（protected）和私有继承（private）三种。<br>不同的继承方式，导致原有基类成员在派生类中的访问属性也有所不同。 </p><p><code>public</code>:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；<br><code>private</code>:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；<br><code>protected</code>:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p><p>若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；<br>若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；<br>若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。<br>如下表：</p><table><thead><tr><th align="center">基类成员权限</th><th align="center">public继承方式</th><th align="center">private继承方式</th><th align="center">protected继承方式</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">public</td><td align="center">private</td><td align="center">protected</td></tr><tr><td align="center">private</td><td align="center">private</td><td align="center">private</td><td align="center">private</td></tr><tr><td align="center">protected</td><td align="center">protected</td><td align="center">private</td><td align="center">protecteds</td></tr></tbody></table><p>例如：公有继承时的访问控制权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123; </span><br><span class="line">private: </span><br><span class="line">int a; </span><br><span class="line">void fun1() </span><br><span class="line">&#123; cout&lt;&lt;a&lt;&lt;endl; &#125; </span><br><span class="line">protected: </span><br><span class="line">int b; </span><br><span class="line">void fun2() </span><br><span class="line">&#123; cout&lt;&lt;c&lt;&lt;endl; &#125;</span><br><span class="line">public: </span><br><span class="line">int c; </span><br><span class="line">void fun3() </span><br><span class="line">&#123; cout&lt;&lt;b&lt;&lt;endl; &#125;</span><br><span class="line">void seta(int i)&#x2F;&#x2F;修改私有成员a的值</span><br><span class="line">&#123; a&#x3D;i;&#125;</span><br><span class="line">int geta()&#x2F;&#x2F;返回私有成员a的值</span><br><span class="line">&#123; return a;&#125;</span><br><span class="line">Base(int i, int j, int k)&#x2F;&#x2F;基类的构造函数</span><br><span class="line">&#123; a&#x3D;i; b&#x3D;j; c&#x3D;k; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sub: public Base </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int d;</span><br><span class="line">public: </span><br><span class="line">Sub(int i, int j, int k, int m):Base(i, j, k) &#x2F;&#x2F;派生类构造函数</span><br><span class="line">&#123; d&#x3D;m; &#125; </span><br><span class="line">void test() </span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;a&lt;&lt;endl; &#x2F;&#x2F;错误，无法访问基类的私有成员</span><br><span class="line">cout&lt;&lt;b&lt;&lt; endl; &#x2F;&#x2F;正确，可以访问基类的保护成员</span><br><span class="line">cout&lt;&lt;c&lt;&lt; endl; &#x2F;&#x2F;正确，可以访问基类的公有成员</span><br><span class="line">&#x2F;&#x2F;fun1(); &#x2F;&#x2F;错误，无法访问基类的私有成员</span><br><span class="line">fun2();&#x2F;&#x2F;正确，可以访问基类的保护成员</span><br><span class="line">fun3();&#x2F;&#x2F;正确，可以访问基类的公有成员</span><br><span class="line">seta(10);&#x2F;&#x2F;正确，间接访问基类成员a</span><br><span class="line">cout &lt;&lt; d &lt;&lt;endl; &#x2F;&#x2F;正确，可以访问派生类的私有成员</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">Base b1(5, 6, 7); </span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt; b1.a; &#x2F;&#x2F;错误，无法访问对象的私有成员</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;b1.b;&#x2F;&#x2F;错误，无法访问对象的保护成员</span><br><span class="line">cout&lt;&lt;b1.c&lt;&lt;endl; &#x2F;&#x2F;正确，可以访问对象的公有成员</span><br><span class="line">cout&lt;&lt;b1.geta()&lt;&lt;endl; &#x2F;&#x2F;正确，间接访问对象的私有成员a</span><br><span class="line">Sub s1(11,15,19,22); </span><br><span class="line">s1.test();&#x2F;&#x2F;正确，可以访问对象的公有成员</span><br><span class="line">s1.c &#x3D; 200;&#x2F;&#x2F;正确，可以访问对象的公有成员</span><br><span class="line">s1.fun3();&#x2F;&#x2F;正确，可以访问对象的公有成员</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h1><p>在继承机制中，基类的构造函数和析构函数是不能继承的。<br>派生类的构造函数负责对来自基类数据成员和新增加的数据成员进行初始化。<br>所以在执行派生类的构造函数时，需要调用基类的构造函数。</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>通过继承，派生类得到了基类的成员，因此派生类对象中既包括自身类的数据成员还包括通过继承从基类中得到的数据成员。<br>在派生类中还可用其他类来定义对象作为成员，又涉及到派生类中对象成员的构造问题，则当用派生类定义对象后，派生类对象、对象成员、基类对象的构造函数的调用顺序如下：</p><ul><li>基类的构造函数。</li><li>对象成员的构造函数（如果有的话），有多个时按声明的顺序。</li><li>派生类的构造函数。</li></ul><p>派生类构造实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">B()&#123; cout&lt;&lt;”Construct B”&lt;&lt;endl ;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">C()&#123; cout&lt;&lt;”Construct C”&lt;&lt;endl ;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class D: public B</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">C  c1;</span><br><span class="line">public:</span><br><span class="line">D()&#123; cout&lt;&lt;”Construct D”&lt;&lt;endl ;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">D  d1;  </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>construct B<br>Construct C<br>Construct D</p><p>析构函数与构造函数执行的顺相反，将按如下顺序执行：</p><ul><li>派生类的构造函数；</li><li>对象成员的构造函数（如果有的话），有多个时与声明的顺序相反；</li><li>基类对象的析构函数。</li></ul><h2 id="构造规则"><a href="#构造规则" class="headerlink" title="构造规则"></a>构造规则</h2><p>在C++中，类的机制非常清楚、严格地划分了各自的权限和责任。是哪个类的操作，必须由那个类调用；<br>是谁的对象，就必须由该类的构造函数来完成对其构造的工作。<br>因此，对派生类中基类成员的构造，必须由基类构造函数完成，而不能由派生类的构造函数越权去构造。<br>派生类构造函数主要负责调用基类构造函数并提供基类构造函数所需的参数。<br>下面分两种情况讨论派生类对象的构造： </p><ul><li>如基类中定义了默认构造函数，且该默认构造函数能够完成派生类对象中基类成员的构造，则派生类构造函数无需显式调用基类构造函数，直接调用基类的默认构造函数即可，这是一种较为简单的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Base()&#123; a&#x3D;0;&#125;</span><br><span class="line">Base(int i)&#123; a&#x3D;i;&#125;</span><br><span class="line">protected:</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Derived()&#123; b&#x3D;0;&#125;</span><br><span class="line">Derived(int i) &#123; b&#x3D;i ;&#125;</span><br><span class="line">void Print()</span><br><span class="line">&#123; </span><br><span class="line">cout&lt;&lt;&quot;a&#x3D;&quot;&lt;&lt;a&lt;&lt;&quot;,b&#x3D;&quot;&lt;&lt;b&lt;&lt;endl ;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int b;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Derived  d1; </span><br><span class="line">Derived  d2(12);</span><br><span class="line">d1.Print();</span><br><span class="line">d2.Print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>a=0,b=0<br>a=0,b=12</p><ul><li>若基类中定义了有参数的构造函数，或者所定义的默认构造函数不能完成基类成员的构造，则必须通过派生类构造函数显式向调用基类的构造函数，向带参数的构造函数传递参数，这需要用到“成员初始化列表”的语法。<br>另外，对于派生类中普通数据成员的初始化，以及对象成员的构造也可以放在成员初始化列表中完成。<br>此时这些以逗号隔开的基类构造函数调用数据成员初始化和构造的放置顺序可以是任意的。<br>因此派生类的构造函数定义一般格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名(参数列表):基类构造函数(参数列表1),子对象成员1（参数列表）……</span><br><span class="line">&#123;</span><br><span class="line">派生类构造函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类构造函数举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;cstring&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">class Date&#x2F;&#x2F;日期类</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int year,mon,day; &#x2F;&#x2F;年、月、日成员变量</span><br><span class="line">public:</span><br><span class="line">Date(int y&#x3D;2009,int m&#x3D;6,int d&#x3D;10)  &#x2F;&#x2F;构造函数</span><br><span class="line">&#123;</span><br><span class="line">year&#x3D;y;mon&#x3D;m;day&#x3D;d;</span><br><span class="line">&#125;</span><br><span class="line">void Print()&#x2F;&#x2F;输出数据，格式为：年-月-日</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;year&lt;&lt;&quot;-&quot;&lt;&lt;mon&lt;&lt;&quot;-&quot;&lt;&lt;day&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student&#x2F;&#x2F;定义学生基类</span><br><span class="line">&#123; </span><br><span class="line">protected:</span><br><span class="line">int number;&#x2F;&#x2F;数据成员</span><br><span class="line">char name[20];</span><br><span class="line">char sex;</span><br><span class="line">public:</span><br><span class="line">Student()&#x2F;&#x2F;重定义的默认构造函数</span><br><span class="line">&#123;</span><br><span class="line">number&#x3D;0;</span><br><span class="line">strcpy(name,&quot;No name&quot;);&#x2F;&#x2F;默认名字</span><br><span class="line">sex&#x3D;&#39;M&#39;;&#x2F;&#x2F;默认性别，男性 (male)d</span><br><span class="line">&#125;</span><br><span class="line">Student(int n,char *s,char x)     &#x2F;&#x2F;带参数的构造函数</span><br><span class="line">&#123;</span><br><span class="line">number&#x3D;n;</span><br><span class="line">strcpy(name,s);</span><br><span class="line">sex&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;大学生派生类</span><br><span class="line">class UGStudent: public Student </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">UGStudent (int n,char *s,char x,int a,int y,int m,int d):</span><br><span class="line">Student(n,s,x),birth(y,m,d)</span><br><span class="line">&#123;</span><br><span class="line">age&#x3D;a; </span><br><span class="line">&#125;</span><br><span class="line">UGStudent () &#x2F;&#x2F;此处省略了Student()调用</span><br><span class="line">&#123;</span><br><span class="line">age&#x3D;0; </span><br><span class="line">&#125;</span><br><span class="line">void Print() &#x2F;&#x2F;输出信息</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;number:&quot;&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;sex:&quot;&lt;&lt;sex&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;birthday:&quot;;</span><br><span class="line">birth.Print();</span><br><span class="line">&#125;</span><br><span class="line">private: </span><br><span class="line">int age;</span><br><span class="line">Date birth;&#x2F;&#x2F;对象成员</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主函数</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">UGStudent st1;&#x2F;&#x2F;用派生的默认构造函数定义对象</span><br><span class="line">UGStudent st2(1001,&quot;Zhang&quot;,&#39;F&#39;,20,2009,6,11);</span><br><span class="line">                           &#x2F;&#x2F;带参数构造</span><br><span class="line">st1.Print();</span><br><span class="line">st2.Print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>number:0<br>name:No name<br>sex:M<br>age:0<br>birthday:2009-6-10<br>number:1001<br>name:Zhang<br>sex:F<br>age:20<br>birthday:2009-6-11</p><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><h2 id="多继承的声明"><a href="#多继承的声明" class="headerlink" title="多继承的声明"></a>多继承的声明</h2><p>多继承下派生类的声明格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 派生类名: 继承方式1  基类名，继承方式2  基类名2…… </span><br><span class="line">&#123; </span><br><span class="line">派生类类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，继承方式1、继承方式2… 是三种继承方式：public、private和protected 之一。 </p><p>在多继承的情况下，派生类的构造函数格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">派生类名（参数列表）:基类名1(参数表1),基类名2(参数表2)……,</span><br><span class="line">子对象名(参数表n)……</span><br><span class="line">&#123; </span><br><span class="line">派生类构造函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多继承下派生类的构造函数与单继承下派生类构造函数相似，它必须同时负责该派生类所有基类构造函数的调用同时，派生类的参数个数必须包含完成所有基类初始化所需的参数个数。<br>派生类构造函数执行顺序是先执行所有基类的构造函数，再执行派生类本身构造函数。<br>处于同一层次的各基类构造函数的执行顺序取决于声明派生类时所指定的各基类顺序，与派生类构造函数中所定义的成员初始化列表的各项顺序无关。<br>另外，析构函数的调用顺序则与构造函数完全相反。</p><p>多继承举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;cstring&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;定义研究生基类</span><br><span class="line">class GStudent</span><br><span class="line">&#123; </span><br><span class="line">protected:</span><br><span class="line">int number;&#x2F;&#x2F;学号 </span><br><span class="line">char name[20];&#x2F;&#x2F;名字</span><br><span class="line">char sex;&#x2F;&#x2F;性别，男性：M,女性：F</span><br><span class="line">public:</span><br><span class="line">GStudent (int n,char *s,char x)&#x2F;&#x2F;带参数的构造函数</span><br><span class="line">&#123;</span><br><span class="line">number&#x3D;n;</span><br><span class="line">strcpy(name,s);</span><br><span class="line">sex&#x3D;x;</span><br><span class="line">cout&lt;&lt;&quot;Construct GStudent.&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~ GStudent()&#x2F;&#x2F;析构函数</span><br><span class="line">&#123; cout&lt;&lt;&quot;Destruct GStudent.&quot;&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Employee&#x2F;&#x2F;职员类</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">char ename[20];&#x2F;&#x2F;职员名字</span><br><span class="line">char jobname[20];&#x2F;&#x2F;工作名</span><br><span class="line">public:</span><br><span class="line">Employee(char *sn,char *sj)&#x2F;&#x2F;构造函数</span><br><span class="line">&#123;</span><br><span class="line">strcpy(ename,sn);</span><br><span class="line">strcpy(jobname,sj);</span><br><span class="line">cout&lt;&lt;&quot;Construct Employee.&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~ Employee ()&#x2F;&#x2F;析构函数</span><br><span class="line">&#123; cout&lt;&lt;&quot;Destruct Employee.&quot;&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在职研究生类，从两个基类派生</span><br><span class="line">class GStudentHasJob: public GStudent,public Employee </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">GStudentHasJob (int n,char *s,char x,char *sj):</span><br><span class="line">GStudent (n,s,x),Employee(s,sj)</span><br><span class="line">&#123;  cout&lt;&lt;&quot;Construct GStudentHasJob.&quot;&lt;&lt;endl;&#125;</span><br><span class="line">~GStudentHasJob ()</span><br><span class="line">&#123; cout&lt;&lt;&quot;Destruct GStudentHasJob.&quot;&lt;&lt;endl;  &#125;</span><br><span class="line">void Print() &#x2F;&#x2F;输出信息</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;number:&quot;&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;sex:&quot;&lt;&lt;sex&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;job:&quot;&lt;&lt;jobname&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主函数</span><br><span class="line">int main() </span><br><span class="line">&#123;&#x2F;&#x2F;定义一个在职研究生对象，并对其初始化</span><br><span class="line">GStudentHasJob st(1001,&quot;zhang&quot;,&#39;F&#39;,&quot;teacher&quot;); </span><br><span class="line">st.Print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>Construct     GStudent.<br>Construct Employee.<br>Construct GStudentHasJob.<br>number:1001<br>name:zhang<br>sex:F<br>job:teacher<br>Destruct GStudentHasJob.<br>Destruct Employee.<br>Destruct GStudent.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象(二)</title>
      <link href="/2019/03/14/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/"/>
      <url>/2019/03/14/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="自引用指针this"><a href="#自引用指针this" class="headerlink" title="自引用指针this"></a>自引用指针this</h1><ul><li>对象的自身引用是面向对象程序设计语言中特有的、十分重要的一种机制。在C++中，为这种机制设立了专门的表示：this指针变量。</li><li>在类的每一个成员函数的形参表中都有一个隐含的指针变量this，该指针变量的类型就是成员函数所属类的类型。</li><li>当程序中调用类的成员函数时，this指针变量被自动初始化为发出函数调用的对象的地址。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Sample</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">public:</span><br><span class="line">Sample(int a&#x3D;0, int b&#x3D;0)</span><br><span class="line">&#123; x&#x3D;a; y&#x3D;b; &#125;</span><br><span class="line">void print()</span><br><span class="line">&#123; cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123; Sample obj(5,10);</span><br><span class="line">  obj.print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上述程序可用this指针显示改写为完全等价的形式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Sample</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">public:</span><br><span class="line">Sample(int a&#x3D;0, int b&#x3D;0)</span><br><span class="line">&#123; this-&gt;x&#x3D;a;                &#x2F;&#x2F;在此例中this&#x3D;&amp;obj</span><br><span class="line">  this-&gt;y&#x3D;b; &#125;</span><br><span class="line">void print()</span><br><span class="line">&#123; cout&lt;&lt;this-&gt;x&lt;&lt;endl;     &#x2F;&#x2F;在此例中this&#x3D;&amp;obj</span><br><span class="line"> cout&lt;&lt;this-&gt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123; Sample obj(5,10);&#x2F;&#x2F;当程序中调用类的成员函数时，this指针变量被自动</span><br><span class="line"> obj.print();&#x2F;&#x2F;初始化为发出函数调用的对象的地址。</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么何时使用this指针呢？</strong><br>编写代码时主要有两种场合要求尽可能使用this指针</p><ul><li>一种是为了区分成员和非成员</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Sample::fun(int x)</span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;x&#x3D;x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>一种使用this指针的应用是一个类的方法需要返回当前对象的引用。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Sample</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line"> int x;</span><br><span class="line">char* ptr;</span><br><span class="line"> public:</span><br><span class="line">Sample &amp; Set(int i, char *p);</span><br><span class="line">    &#x2F;&#x2F;..</span><br><span class="line">&#125;;</span><br><span class="line">Sample&amp; Sample::Set(int i, char *p);&#x2F;&#x2F;方法Set返回当前对象的引用，*this就是当前对象。</span><br><span class="line">&#123;</span><br><span class="line"> x&#x3D;i;</span><br><span class="line"> ptr&#x3D;p;</span><br><span class="line"> return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象数组与对象指针"><a href="#对象数组与对象指针" class="headerlink" title="对象数组与对象指针"></a>对象数组与对象指针</h1><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>所谓对象数组是指每一数组元素都是对象的数组，也就是说，若一个类有若干个对象，我们把这一系列的对象用一个数组来存放。<br>对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。定义对象数组时，系统为每个数组元素对象调用一次构造函数以构造这些元素。<br>对象数组的定义的格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 数组名 [数组大小]；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student stu[3];</span><br><span class="line">  定义了类Student的对象数组stu。</span><br><span class="line">  系统调用无参构造函数3次。</span><br></pre></td></tr></table></figure><p>如果类<code>Student</code>有2个数据成员姓名<code>（char name[10]）、年龄(int age)</code>，那么在定义对象数组时也可以实现初始化。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu[3]&#x3D;&#123; Student(“zhao”,22),  Student(“qian”,20),  Student(“sun”，8,90)  &#125;;</span><br></pre></td></tr></table></figure><p>在建立对象数组时，分别调用构造函数，对每个元素初始化。<br>与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，也就是一个对象，通过这个对象，也可以访问到它的公有成员，一般形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名［下标］. 成员名</span><br></pre></td></tr></table></figure><p>对象数组的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Sample</span><br><span class="line">&#123;</span><br><span class="line">    private:</span><br><span class="line">        int x;</span><br><span class="line">public:</span><br><span class="line">void Set_x(int n)</span><br><span class="line">&#123; x&#x3D;n; &#125;</span><br><span class="line">int Get_x()</span><br><span class="line">&#123;  return x;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Sample obj[4];</span><br><span class="line">int i;</span><br><span class="line">for(i&#x3D;0; i&lt;4; i++)</span><br><span class="line">obj[i].Set_x(i);</span><br><span class="line">for(i&#x3D;0; i&lt;4; i++)</span><br><span class="line">cout&lt;&lt;obj[i].Get_x()&lt;&lt;” ”;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：0 1 2 3</p><h2 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h2><p>使用new运算符动态分配的对象属于堆对象，其所占存储空间被分配在堆区。</p><p>利用new建立对象会自动调用构造函数，利用delete删除对象会自动调用析构函数。<br>堆对象的建立与删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Date&#x2F;&#x2F;定义日期类Date</span><br><span class="line">&#123;private:</span><br><span class="line">int month, day,  year;</span><br><span class="line">public:</span><br><span class="line">Date(int m, int d, int y);&#x2F;&#x2F;声明构造函数</span><br><span class="line">&#125;;</span><br><span class="line">Date::Date(int m, int d, int y) 　　&#x2F;&#x2F;定义构造函数</span><br><span class="line">&#123;if (m&gt;0 &amp;&amp; m&lt;13)</span><br><span class="line">month&#x3D;m;</span><br><span class="line">if (d&gt;0 &amp;&amp; d&lt;32)</span><br><span class="line">      day&#x3D;d;  </span><br><span class="line">if (y&gt;0 &amp;&amp; y&lt;3000)</span><br><span class="line">year&#x3D;y;  </span><br><span class="line">&#125;</span><br><span class="line">int main()　　　　　　　　　</span><br><span class="line">&#123;Date *pd;              &#x2F;&#x2F;定义一个指向Date类的对象的指针变量pd</span><br><span class="line">    pd&#x3D;new Date(1,1,2008);  &#x2F;&#x2F;pd指向新建Date类的对象的起始地址</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">    delete(pd);&#x2F;&#x2F;释放pd所指向的内存空间</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><p>指向类对象的指针称为对象指针。</p><p>声明指向类对象的指针变量的一般形式为<br>     <code>类名 *对象指针名;</code><br>用指针引用单个对象成员的方法与其他基本类型指针相同，可以有两种形式：<br>   <code>指针变量名-&gt;成员名</code><br>或<br>   <code>(*指针变量名).成员名</code><br>可以通过对象指针访问对象和对象的成员。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date obj, *pt;</span><br><span class="line">pt&#x3D;&amp;obj;</span><br></pre></td></tr></table></figure><p>定义指向Date类对象obj的指针变量pt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*pt             &#x2F;&#x2F;pt所指向的对象，即obj</span><br><span class="line">(*pt).year  &#x2F;&#x2F;pt所指向的对象obj中的year成员，即obj.year</span><br><span class="line">pt-&gt;year&#x2F;&#x2F;pt所指向的对象obj中的year成员，即obj.year</span><br><span class="line">(*pt).get_date()   &#x2F;&#x2F;调用所指向的对象obj中的get_date函数，即obj.getdate()</span><br><span class="line">pt-&gt;get_date        &#x2F;&#x2F;调用所指向的对象obj中的get_date函数，即obj.getdate()</span><br></pre></td></tr></table></figure><p>有关对象指针的使用方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Date&#x2F;&#x2F;定义日期类Date</span><br><span class="line">&#123;private:</span><br><span class="line">int month, day,  year;</span><br><span class="line">public:</span><br><span class="line">Date(int m, int d, int y);&#x2F;&#x2F;声明构造函数</span><br><span class="line">void showDate();　　　　 &#x2F;&#x2F;声明显示数据成员值的成员函数</span><br><span class="line">&#125;;</span><br><span class="line">Date::Date(int m, int d, int y) 　　&#x2F;&#x2F;定义构造函数</span><br><span class="line">&#123;if (m&gt;0 &amp;&amp; m&lt;13)</span><br><span class="line">month&#x3D;m;</span><br><span class="line">if (d&gt;0 &amp;&amp; d&lt;32)</span><br><span class="line">      day&#x3D;d;  </span><br><span class="line">if (y&gt;0 &amp;&amp; y&lt;3000)</span><br><span class="line">year&#x3D;y;  </span><br><span class="line">&#125;</span><br><span class="line">void Date::showDate()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;year&lt;&lt;”.”&lt;&lt;month&lt;&lt;”.”&lt;&lt;day&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Date obj(2008,1,1);  &#x2F;&#x2F;定义Date类对象obj</span><br><span class="line">int *pt1&#x3D;&amp;obj.year;  </span><br><span class="line">        &#x2F;&#x2F;定义指向整型数据的指针变量pt1，并使pt1  指向obj.year</span><br><span class="line">cout&lt;&lt;*pt1&lt;&lt;endl;  &#x2F;&#x2F;输出pt1所指向的数据成员obj.year</span><br><span class="line">obj.showDate();    &#x2F;&#x2F;调用对象obj的成员函数showDate()</span><br><span class="line">Date *pt2&#x3D;&amp;obj;   </span><br><span class="line">              &#x2F;&#x2F;定义指向Date类对象的指针变量pt2，并使pt2指向obj</span><br><span class="line">pt2-&gt;showDate();  &#x2F;&#x2F;调用pt2所指向对象obj的showDate()函数</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>2008<br>2008.1.1<br>2008.1.1</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>为了实现一个类的不同对象之间的数据和函数共享，C++提出了静态成员的概念。静态成员包括:</p><ul><li>静态数据成员</li><li>静态函数成员</li></ul><p>在类的定义中，可以用关键字static声明成员为静态成员，这些静态成员可以在同一个类的不同对象之间提供数据共享。<br>不管这个类创建了多少个对象，但静态成员只有一份拷贝（副本），为所有属于这个类的对象所共享。</p><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>公有的静态数据成员可以在对象定义之前被访问，形式为：<br>   <code>类名：：公有静态成员变量名；</code><br>在对象定义后还可以通过对象进行访问，形式为：<br>   <code>对象名.公有静态成员变量名；</code><br>私有的静态数据成员不能被类的外部函数访问，也不能用对象进行访问。<br>静态数据成员的初始化必须在类外进行，默认值为0，它是在编译时创建并初始化，所以它在该类的任何对象被创建前就存在。</p><p>静态数据成员的定义与使用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Ctype</span><br><span class="line">&#123;private:</span><br><span class="line">int a;           </span><br><span class="line">static int s;                &#x2F;&#x2F;定义私有的静态数据成员s</span><br><span class="line">public:</span><br><span class="line">void print();</span><br><span class="line">Ctype(int x&#x3D;0);</span><br><span class="line">&#125;;</span><br><span class="line">void Ctype::print()</span><br><span class="line">&#123; cout&lt;&lt;”a&#x3D;”&lt;&lt;++a&lt;&lt;endl;  &#x2F;&#x2F;输出普通数据成员</span><br><span class="line"> cout&lt;&lt;”s&#x3D;”&lt;&lt;++s&lt;&lt;endl;  &#x2F;&#x2F;输出静态数据成员，两者作比较</span><br><span class="line"> &#125;</span><br><span class="line">Ctype::Ctype(int x)</span><br><span class="line">&#123;  a&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line">int Ctype::s&#x3D;0;          &#x2F;&#x2F;静态数据成员赋初值在类体外进行，前面不能再加static</span><br><span class="line">int main()</span><br><span class="line">&#123;  Ctype c1,c2,c3;     &#x2F;&#x2F;定义3个对象，都使用默认的参数值</span><br><span class="line">c1.print();         </span><br><span class="line">c2.print();</span><br><span class="line">c3.print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>a=1<br>s=1<br>a=1<br>s=2<br>a=1<br>s=3</p><p>静态数据成员和一般数据成员的不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">static int count;&#x2F;&#x2F;声明静态数据成员count，统计学生的总数</span><br><span class="line">int StudentNo;&#x2F;&#x2F;普通数据成员，用于表示每个学生的学号</span><br><span class="line">public:</span><br><span class="line">Student()&#x2F;&#x2F;构造函数</span><br><span class="line">&#123;</span><br><span class="line">++count;&#x2F;&#x2F;每创建一个学生对象，学生数加1</span><br><span class="line">StudentNo&#x3D;count;&#x2F;&#x2F;给当前学生的学号赋值</span><br><span class="line">&#125;</span><br><span class="line">void Print()&#x2F;&#x2F;成员函数，显示学生的学号和当前学生数</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;”Student”&lt;&lt;StudentNo&lt;&lt;”  ”;</span><br><span class="line">cout&lt;&lt;”count&#x3D;”&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Student::count&#x3D;0;&#x2F;&#x2F;给静态数据成员couny赋初值</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Student Student1;&#x2F;&#x2F;创建第1个学生对象</span><br><span class="line">Student1.print();</span><br><span class="line">cout&lt;&lt;&quot;---------&quot;&lt;&lt;endl;</span><br><span class="line">Student Student2;&#x2F;&#x2F;创建第2个学生对象 Student2</span><br><span class="line">Student1.Print();</span><br><span class="line">Student2.Print();</span><br><span class="line">cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;</span><br><span class="line">Student Student3;&#x2F;&#x2F;创建第3个学生对象Student3</span><br><span class="line">Student1.Print();</span><br><span class="line">Student2.Print();</span><br><span class="line">Student3.Print();</span><br><span class="line">cout&lt;&lt;&quot;----------&quot;&lt;&lt;endl;;</span><br><span class="line">Student Student4;&#x2F;&#x2F;创建第4个学生对象Student4</span><br><span class="line">Student1.Print();</span><br><span class="line">Student2.Print();</span><br><span class="line">Student3.Print();</span><br><span class="line">Student4.Print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Studentl count&#x3D;1</span><br><span class="line">----------</span><br><span class="line">Studentl count&#x3D;2</span><br><span class="line">Student2 count&#x3D;2</span><br><span class="line">----------</span><br><span class="line">Studentl count&#x3D;3</span><br><span class="line">Student2 count&#x3D;3</span><br><span class="line">Student3 count&#x3D;3</span><br><span class="line">----------</span><br><span class="line">Studentl count&#x3D;4</span><br><span class="line">Student2 count&#x3D;4</span><br><span class="line">Student3 count&#x3D;4</span><br><span class="line">Student4 count&#x3D;4</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>在类定义中，声明为static的成员函数能在类的范围内共享，把这样的成员函数称为静态成员函数。<br>静态成员函数属于整个类，是该类所有对象共享的成员函数，而不属于类中的某个对象。<br>静态成员函数只能访问静态数据成员，不能对类的其他类型的数据成员或成员函数进行访问，可以通过对象或类名进行调用。</p><p>定义静态成员函数的格式为<br>    <code>static返回类型 静态成员函数名（参数表）；</code><br>与静态数据成员类似，调用公有静态成员函数的一般格式为<br>  <code>类名：：静态成员函数名（实参表）</code><br>  <code>对象．静态成员函数名（实参表）</code></p><p>关于静态成员函数的使用有以下几点说明：</p><ol><li>静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时，不用static前缀。</li><li>一般情况下，静态函数成员主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。</li><li>私有静态成员函数不能被类外部函数和对象访问。</li><li>使用静态成员函数的一个原因是，可以用它在建立任何对象之前处理静态数据成员，这是普通成员函数不能实现的功能。</li><li>编译系统将静态成员函数限定为内部连接，也就是说，与现行文件相连接的其他文件中的同名函数不会与该函数发生冲突，维护了该函数使用的安全性，这是使用静态成员函数的另一个原因。</li><li>在一般的成员函数中都隐含有一个this指针，用来指向对象自身，而在静态成员函数中是没有this指针的。</li><li>一般而言，静态成员函数不访问类中的非静态成员。若确实需要，静态成员函数只能通过对象名（或指向对象的指针）访问该对象的非静态成员。</li></ol><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>类的一个很重要的特点就是实现了数据隐藏和封装。在类定义的时候，一般都将数据成员声明为私有成员（或保护成员），只能在类定义的范围内使用，也就是说私有成员（或保护成员）只能通过它的成员函数来访问。</p><p>但是，调用公有函数接口是需要时间开销的，且有时候需要在类的外部访问类的私有成员（或保护成员）。<br>为此，就需要寻找一种途径，在不放弃私有成员（或保护成员）数据安全性的情况下，使得一个普通函数或者类的成员函数可以访问到封装于某一类中的信息（私有、保护成员） 。</p><p>在C++语言中，通过定义<strong>友元</strong>（friend member）来实现这一功能。类的友元包括<strong>友元函数</strong>和<strong>友元类</strong>。</p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数有2种形式：</p><ul><li>一个不属于任何类的普通函数声明为当前类的友元，称为当前类的友元函数。</li><li>一个其他类的成员函数声明为当前类的友元，称为当前类的友元成员。</li></ul><p>友元函数是在类中说明的由关键字friend修饰的非成员函数。<br>友元函数不是当前类的成员函数，而是独立于当前类的外部函数，但它可以访问该类的所有对象的成员，包括私有成员、保护成员和公有成员。<br>在类中声明友元函数时，需在其函数名前加上关键字friend。此声明可以放在公有部分，也可以放在保护部分和私有部分。<br>友元函数可以定义在类内部，也可以定义在类的外部。</p><p>友元函数的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line"> int x, y;</span><br><span class="line"> public:</span><br><span class="line">Point(int a&#x3D;0, int b&#x3D;0)</span><br><span class="line">&#123;  x&#x3D;a; y&#x3D;b;  &#125;</span><br><span class="line">~Point()  &#123;  &#125;</span><br><span class="line">void Show()</span><br><span class="line">&#123; cout&lt;&lt;”x&#x3D;”&lt;&lt;x&lt;&lt;” y&#x3D;”&lt;&lt;y&lt;&lt;endl;   &#125;</span><br><span class="line">int Get_x()</span><br><span class="line">&#123;  return x;  &#125;</span><br><span class="line">int Get_y()</span><br><span class="line">&#123;  return y;  &#125;</span><br><span class="line">friend double Distance(Point &amp;p1, Point &amp;p2);  &#x2F;&#x2F;友元函数声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double Distance(Point &amp;p1, Point &amp;p2)   &#x2F;&#x2F;友元函数定义</span><br><span class="line">&#123;</span><br><span class="line">return  sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123; Point p1, p2(1,1);</span><br><span class="line">  cout&lt;&lt;Distance(p1,p2)&lt;&lt;endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元函数的说明：</p><ul><li>友元函数不是类的成员函数。因此，对友元函数指定访问权限无效，可以把友元函数的说明放在<code>private</code>、<code>public</code>、<code>protected</code>的任意段中。在类的外部定义友元函数时，不必像成员函数那样，在函数名前加上<code>类名::</code>。</li><li>使用友元函数的目的是提高程序的运行效率。</li><li>慎用友元函数，因为它可在类外直接访问类的私有或保护成员，破坏了类的信息隐藏的特性。</li></ul><h2 id="友元成员"><a href="#友元成员" class="headerlink" title="友元成员"></a>友元成员</h2><p>除了一般的函数可以作为某个类的友元外，一个类的成员函数也可以作为另一个类的友元。<br>这种成员函数不仅可以访问自己所在类对象中的所有成员，还可以访问friend声明语句所在类对象中的所有成员。<br>这样能使两个类相互合作、协调工作，完成某一任务。</p><p>将一个类的成员函数说明为另一个类的友元函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class N;       &#x2F;&#x2F;N类的前向说明，因为N的定义在M之后，而M中使用了N</span><br><span class="line">class M</span><br><span class="line">&#123;</span><br><span class="line">  int a, b;</span><br><span class="line">public:</span><br><span class="line">  M(int x, int y)</span><br><span class="line">  &#123; a&#x3D;x; b&#x3D;y; &#125;</span><br><span class="line">  void Print()</span><br><span class="line">  &#123; cout&lt;&lt;”a&#x3D;”&lt;&lt;a&lt;&lt;” b&#x3D;”&lt;&lt;b&lt;&lt;endl;  &#125;</span><br><span class="line">  void Setab(N &amp;);</span><br><span class="line">&#125;;</span><br><span class="line">class N</span><br><span class="line">&#123;</span><br><span class="line">  int c, d;</span><br><span class="line">  public:</span><br><span class="line">N(int a, int b)</span><br><span class="line">&#123; c&#x3D;a; d&#x3D;b; &#125;</span><br><span class="line">  void Print()</span><br><span class="line">  &#123; cout&lt;&lt;”c&#x3D;”&lt;&lt;c&lt;&lt;” d&#x3D;”&lt;&lt;d&lt;&lt;endl;  &#125;</span><br><span class="line">      friend void M::Setab(N&amp;);   &#x2F;&#x2F;将M类的成员函数说明为本类的友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void M::Setab(N &amp;obj)    &#x2F;&#x2F;M类的成员函数Setab()是类N的友元函数</span><br><span class="line">&#123;</span><br><span class="line">  a&#x3D;obj.c;            &#x2F;&#x2F;在Setab()中可以直接访问类N的私有成员</span><br><span class="line">  b&#x3D;obj.d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123; M m(25, 40);</span><br><span class="line">  N n(55,66);</span><br><span class="line">  cout&lt;&lt;”m: ”;</span><br><span class="line">  m.Print();</span><br><span class="line">  cout&lt;&lt;”n: ”;</span><br><span class="line">  n.Print();</span><br><span class="line">  m.Setab(n);</span><br><span class="line">  cout&lt;&lt;”m: ”;</span><br><span class="line">  m.Print();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>m: a=25 b=40<br>n: c=55 d=66<br>m: a=55 b=66</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元还可以是类，即一个类可以作为另一个类的友元。<br>当一个类作为另一个类的友元时，则该类中的所有成员函数都是另一个类的友元成员，都可以访问另一个类的所有成员。<br>友元类的声明格式为：<br>   <code>friend 类名；</code><br>此语句可以放在公有部分也可以放在私有部分或保护部分。</p><p>将一个类说明为另一个类的友元类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class B;  &#x2F;&#x2F; 前向说明，因为在后面定义的A类中用到B类</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line"> int x;</span><br><span class="line"> public: </span><br><span class="line">A(int a)</span><br><span class="line">&#123;  x&#x3D;a;  &#125;</span><br><span class="line">  friend class B;  &#x2F;&#x2F;将类B声明为类A的友元类</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Show(A  a)</span><br><span class="line">  &#123; cout&lt;&lt;”x&#x3D;”&lt;&lt;a.x&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a(10);</span><br><span class="line">B b;</span><br><span class="line">b.Show(a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>x=10 </p><p>说明：</p><ul><li>本例中，类B是类A的友元，因此，在类B的成员函数中可以访问类A的任何成员。</li><li>友元关系是单向的，不具有交换性，即类A中将类B声明为自己的友元类，但类B中没有将类A声明为友元类，所以类A的成员函数不可以访问类B的私有成员。</li><li>当两个类都将对方声明为自己的友元时，才可以实现互访。</li><li>友元关系也不具备传递性，即类A将类B声明为友元，类B将类C声明为友元，此时，类C不一定是类A的友元。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象(一)</title>
      <link href="/2019/03/12/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%80)/"/>
      <url>/2019/03/12/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h1><p>类是把各种不同类型的数据和对数据的操作组织在一起而形成的的用户自定义的数据类型，其中，把不同类型的数据称为数据成员，把对数据的操作称为成员函数。</p><h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><p>类的声明格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#x2F;&#x2F;类名由用户自定义，一般首字母大写</span><br><span class="line">｛</span><br><span class="line">&#x2F;&#x2F;访问属性后跟“：”来指定</span><br><span class="line">[private:] &#x2F;&#x2F;只能由本类的成员函数访问</span><br><span class="line">私有数据成员；</span><br><span class="line">私有成员函数；</span><br><span class="line">protected:&#x2F;&#x2F;可由本类和本类的派生类成员函数访问</span><br><span class="line">保护数据成员；</span><br><span class="line">保护成员函数；</span><br><span class="line">public:&#x2F;&#x2F;可由程序中的函数访问，是对外开放的</span><br><span class="line">公有数据成员；</span><br><span class="line">公有成员函数；</span><br><span class="line">｝；&#x2F;&#x2F;类体后以“；”结束</span><br></pre></td></tr></table></figure><p>说明：一般情况下，数据成员应声明为私有成员，成员函数为公有成员，如不做声明默认为私有的，不能在声明中给数据成员赋初值。</p><p>用struct声明的类和class声明的类的主要区别是默认访问属性不同。在类class中默认访问属性为private，在结构体struct中默认访问属性为public。<a id="more"></a></p><h1 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h1><p>成员函数可以定义在类定义内部，或者单独使用范围解析运算符 <code>::</code> 来定义。</p><ul><li>内部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;      &#x2F;&#x2F; 长度</span><br><span class="line">      double breadth;     &#x2F;&#x2F; 宽度</span><br><span class="line">      double height;      &#x2F;&#x2F; 高度</span><br><span class="line">   </span><br><span class="line">      double getVolume(void) &#x2F;&#x2F;返回体积</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>外部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;         &#x2F;&#x2F; 长度</span><br><span class="line">      double breadth;        &#x2F;&#x2F; 宽度</span><br><span class="line">      double height;         &#x2F;&#x2F; 高度</span><br><span class="line">      double getVolume(void);&#x2F;&#x2F; 返回体积</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double Box::getVolume(void)</span><br><span class="line">&#123;</span><br><span class="line">    return length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，需要强调一点，在 <code>::</code> 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符<code>.</code>，这样它就能操作与该对象相关的数据，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box myBox;          &#x2F;&#x2F; 创建一个对象</span><br><span class="line"> </span><br><span class="line">myBox.getVolume();  &#x2F;&#x2F; 调用该对象的成员函数</span><br></pre></td></tr></table></figure><p>完整示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;         &#x2F;&#x2F; 长度</span><br><span class="line">      double breadth;        &#x2F;&#x2F; 宽度</span><br><span class="line">      double height;         &#x2F;&#x2F; 高度</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 成员函数声明</span><br><span class="line">      double getVolume(void);</span><br><span class="line">      void setLength( double len );</span><br><span class="line">      void setBreadth( double bre );</span><br><span class="line">      void setHeight( double hei );</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 成员函数定义</span><br><span class="line">double Box::getVolume(void)</span><br><span class="line">&#123;</span><br><span class="line">    return length * breadth * height;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Box::setLength( double len )</span><br><span class="line">&#123;</span><br><span class="line">    length &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Box::setBreadth( double bre )</span><br><span class="line">&#123;</span><br><span class="line">    breadth &#x3D; bre;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Box::setHeight( double hei )</span><br><span class="line">&#123;</span><br><span class="line">    height &#x3D; hei;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box Box1;                &#x2F;&#x2F; 声明 Box1，类型为 Box</span><br><span class="line">   Box Box2;                &#x2F;&#x2F; 声明 Box2，类型为 Box</span><br><span class="line">   double volume &#x3D; 0.0;     &#x2F;&#x2F; 用于存储体积</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; box 1 详述</span><br><span class="line">   Box1.setLength(6.0); </span><br><span class="line">   Box1.setBreadth(7.0); </span><br><span class="line">   Box1.setHeight(5.0);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; box 2 详述</span><br><span class="line">   Box2.setLength(12.0); </span><br><span class="line">   Box2.setBreadth(13.0); </span><br><span class="line">   Box2.setHeight(10.0);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; box 1 的体积</span><br><span class="line">   volume &#x3D; Box1.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; box 2 的体积</span><br><span class="line">   volume &#x3D; Box2.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br></pre></td></tr></table></figure><h1 id="对象的定义与访问"><a href="#对象的定义与访问" class="headerlink" title="对象的定义与访问"></a>对象的定义与访问</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>在类声明的同时直接定义对象<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point</span><br><span class="line">｛</span><br><span class="line">private：</span><br><span class="line">int x,y;</span><br><span class="line">public:</span><br><span class="line">void SetPoint(int,int);</span><br><span class="line">int Getx();</span><br><span class="line">int Gety();</span><br><span class="line">｝op1,op2;&#x2F;&#x2F;直接定义对象</span><br></pre></td></tr></table></figure></li><li>在声明类后再定义对象<br>格式：<code>类名 对象名（参数表）</code><br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">Point op1,op2;&#x2F;&#x2F;主函数中定义对象</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ol><li>成员运算符<code>.</code>访问<br>格式：<code>对象名.成员名</code> 或 <code>(*指向对象的指针).成员名</code></li><li>指针访问形式<br>格式：<code>对象指针变量名-&gt;成员名</code> 或 <code>(&amp;对象名)-&gt;成员名</code></li></ol><h1 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数（Constructor）是与类名同名的特殊的成员函数，当定义该类的对象时，构造函数被系统自动调用，以实现对该对象的初始化。<br>说明：</p><ol><li>必须与类名相同</li><li>没有返回值类型，前面不能加void</li><li>构造函数为public属性</li><li>构造函数可以重载</li></ol><h2 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h2><p>在声明类时不能在数据成员声明中对数据成员进行初始化，数据成员初始化工作一般在构造函数中用赋值语句进行。但是对于常量类型和引用类型的数据成员，又不能在构造函数中直接赋值，所以C++提供了成员初始化表的置初值方式。<br>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名::构造函数名([参数表])[:成员初始化表] &#x2F;&#x2F;[]中内容可省略</span><br><span class="line">｛</span><br><span class="line">&#x2F;&#x2F;构造函数体</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>其中成员初始化表的一般形式为：<br><code>数据成员名1（初始值1）,数据成员名2（初始值2）...</code><br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CMyClass &#123;&#x2F;&#x2F;定义类</span><br><span class="line">    CMyClass(int x, int y);&#x2F;&#x2F;定义构造函数</span><br><span class="line">    int m_x;&#x2F;&#x2F;定义数据成员</span><br><span class="line">    int m_y;&#x2F;&#x2F;定义数据成员</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyClass::CMyClass(int x, int y) : m_y(y), m_x(m_y) &#x2F;&#x2F;成员初始化表，即m_y&#x3D;y, m_x&#x3D;m_y</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数也是一种特殊的成员函数，它执行与构造函数相反的操作，通常用于撤销对象时的一些清理任务，如释放分配给对象的内存空间等。<br>格式：在类名前加“~”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~类名()</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>没有返回值和参数</li><li>不能随意调用</li><li>没有重载</li><li>只在对象生存期结束时系统自动调用</li></ol><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>用于实现对象值的拷贝。通过将一个同类对象的值拷贝给新的对象，而完成对新对象的初始化，即用一个对象去构造另一个对象。<br>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(const类名 &amp;对象名)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数的函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2019/03/12/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/03/12/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>程序运行时常会碰到一些异常情况，例如：</p><blockquote><p>做除法的时候除数为 0；<br>用户输入年龄时输入了一个负数；<br>用 <code>new</code> 运算符动态分配空间时，空间不够导致无法分配；<br>访问数组元素时，下标越界；打开文件读取时，文件不存在。</p></blockquote><p>这些异常情况，如果不能发现并加以处理，很可能会导致程序崩溃。所谓“处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。</p><a id="more"></a><p>C++ 引入了异常处理机制。其<strong>基本思想</strong>是：函数A在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给A的调用者，假定为函数B。拋出异常而不加处理会导致函数A立即中止，在这种情况下，函数B可以选择捕获A拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给B的调用者，以此类推。如果一层层的函数都不处理异常，异常最终会被拋给最外层的main函数。main函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p><h1 id="C-异常处理基本语法"><a href="#C-异常处理基本语法" class="headerlink" title="C++异常处理基本语法"></a>C++异常处理基本语法</h1><p>C++ 通过 throw 语句和 try…catch 语句实现对异常的处理。<br>throw 语句的语法如下：</p><p><code>throw  表达式;</code><br>该语句拋出一个异常。异常是一个表达式，其值的类型可以是基本类型，也可以是类。</p><p>try…catch 语句的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line">catch(异常类型) &#123;</span><br><span class="line">    异常处理代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">catch(异常类型) &#123;</span><br><span class="line">    异常处理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch 可以有多个，但至少要有一个。不妨把try和其后{}中的内容称作“try块”，把 catch 和其后{}中的内容称作“catch块”。</p><p><strong>try…catch 语句的执行过程是</strong>：</p><ul><li>执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；</li><li>如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。</li></ul><p>例如如下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double m ,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    try &#123;</span><br><span class="line">        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;</span><br><span class="line">        if( n &#x3D;&#x3D; 0)</span><br><span class="line">            throw -1; &#x2F;&#x2F;抛出int类型异常</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; m &#x2F; n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(double d) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch(double) &quot; &lt;&lt; d &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(int e) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch(int) &quot; &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：<br>9 6↙<br>before dividing.<br>1.5<br>after dividing.<br>finished</p><p>说明当 n 不为 0 时，try 块中不会拋出异常。因此程序在 try 块正常执行完后，越过所有的 catch 块继续执行，catch 块一个也不会执行。</p><p>程序的运行结果也可能如下：<br>9 0↙<br>before dividing.<br>catch(int) -1<br>finished</p><p>当 n 为 0 时，try 块中会拋出一个整型异常。拋出异常后，try 块立即停止执行。该整型异常会被类型匹配的第一个 catch 块捕获，即进入<code>catch(int e)</code>块执行，该 catch 块执行完毕后，程序继续往后执行，直到正常结束。</p><p>如果拋出的异常没有被 catch 块捕获，例如，将<code>catch(int e)</code>，改为<code>catch(char e)</code>，当输入的 n 为 0 时，拋出的整型异常就没有 catch 块能捕获，这个异常也就得不到处理，那么程序就会立即中止，<code>try...catch</code>后面的内容都不会被执行。 </p><h1 id="能够捕获任何异常的-catch-语句"><a href="#能够捕获任何异常的-catch-语句" class="headerlink" title="能够捕获任何异常的 catch 语句"></a>能够捕获任何异常的 catch 语句</h1><p>如果希望不论拋出哪种类型的异常都能捕获，可以编写如下 catch 块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的 catch 块能够捕获任何还没有被捕获的异常。例如下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    try &#123;</span><br><span class="line">        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;</span><br><span class="line">        if (n &#x3D;&#x3D; 0)</span><br><span class="line">            throw - 1;  &#x2F;&#x2F;抛出整型异常</span><br><span class="line">        else if (m &#x3D;&#x3D; 0)</span><br><span class="line">            throw - 1.0;  &#x2F;&#x2F;拋出 double 型异常</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; m &#x2F; n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (double d) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：<br>9 0↙<br>before dividing.<br>catch (…)<br>finished</p><p>当 n 为 0 时，拋出的整型异常被<code>catchy(...)</code>捕获。</p><p>程序的运行结果也可能如下：<br>0 6↙<br>before dividing.<br>catch (double) -1<br>finished</p><p>当 m 为 0 时，拋出一个 double 类型的异常。虽然<code>catch (double)</code>和<code>catch(...)</code>都能匹配该异常，但是<code>catch(double)</code>是第一个能匹配的 catch 块，因此会执行它，而不会执行<code>catch(...)</code>块。</p><p>由于<code>catch(...)</code>能匹配任何类型的异常，它后面的 catch 块实际上就不起作用，因此不要将它写在其他 catch 块前面。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言基础</title>
      <link href="/2019/03/08/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/08/C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h1><h2 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h2><p><strong>面向过程</strong>        <code>程序=算法+数据结构</code></p><ul><li>特点：以功能为基础，把数据和对数据操作的过程相分离</li><li>优点：结构清晰，模块化强</li><li>缺点：代码可重用性差，不利于维护和扩充</li></ul><a id="more"></a><p><strong>面向对象</strong>     <code>程序=对象+消息</code></p><ul><li>特点：以数据为基础，把数据和对数据操作的过程相作为一个整体，数据本身对外界是隐藏的</li><li>优点：代码可重用，安全方便，利于维护和扩充</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h3><p>面向对象程序设计认为客观世界由对象组成。对象既有静态的<strong>属性</strong>（attribute），又有动态的<strong>方法</strong>（method），或行为。</p><h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><p>具有相似属性和行为的一组对象称为类，实质上是一种类型，包括<strong>数据成员</strong>和<strong>成员函数</strong>，体现了面向对象程序设计以数据为基础，把数据和对数据操作的过程相作为一个整体。<br>面向对象程序设计先声明类再由类生成其对象，类是建立对象的“模板”，再由模板建立一个个具体的对象。</p><h3 id="消息（message）"><a href="#消息（message）" class="headerlink" title="消息（message）"></a>消息（message）</h3><p>一个对象向另一个对象发出的执行某种操作的请求，本质是一个对象对类的成员函数的一次调用。</p><h3 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h3><p>方法是对象能执行的操作。方法是通过函数实现的，称为成员函数。</p><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><p>1.<strong>抽象性</strong>（abstraction）<br>抽象是通过特定实例（对象）抽取共同性质后形成概念的过程，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>。<br>2.<strong>封装性</strong>（encapsulation）<br>把数据和实现操作的代码集中起来放在对象的内部，并尽可能隐藏对象的内部细节。<br>3.<strong>继承性</strong>（inheritance）<br>在已有类的基础上通过增加新特征而派生出新的类称为继承。原有类为基类，新建立的类为派生类。<br>4.<strong>多态性</strong>（polymorphism）<br>指不同对不同的对象收到相同消息时产生多种不同的行为方式。C++语言支持两种多态性，即编译时的多态性和运行时的多态性。编译时的多态性是通过重载来实现的，运行时的多态性是通过虚函数实现的。<br>重载一般包括函数重载和运算符重载，函数重载是一个标识符可同时用于多个函数命名，运算符重载是一个运算符可用于多种运算，即相同名字在不同场合表现出不同行为。</p><h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>用来防止命名冲突。<br>1.<strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace 名字空间名称&#x2F;&#x2F;以namespace开头，后接合法用户自定义标识符</span><br><span class="line">&#123;</span><br><span class="line">... ;</span><br><span class="line">&#125;&#x2F;&#x2F;右花括号后不加分号</span><br></pre></td></tr></table></figure><p>2.<strong>使用</strong><br><strong>方法一</strong><br><code>名字空间名称::局部内容名；</code>    其中的<code>::</code>称为域解析符或作用于运算符。<br><strong>方法二</strong><br>在使用该内容之前用：<br><code>using namespace 名字空间名称；</code><br><strong>方法三</strong><br>在使用公内容之间用：<br><code>using 名字空间名称::局部内容名；</code></p><h2 id="C-中函数的新特性"><a href="#C-中函数的新特性" class="headerlink" title="C++中函数的新特性"></a>C++中函数的新特性</h2><h3 id="函数的原型"><a href="#函数的原型" class="headerlink" title="函数的原型"></a>函数的原型</h3><p>原型声明形式：<br><code>函数返回值类型 函数名（形式参数表）;</code><br>返回值类型建议都要给定，没有返回值时，必须声明为void。<br>函数原型参数表中必须指明形参个数和类型，形参名可以省略。但是在函数定义的首部要给出形参名称。<br>例如：<code>float Fun(int a,float b);</code>和<code>float Fun(int,float);</code>完全等价。<br>如果原型声明时形参表为空，则该函数的参数表为void，表示不带任何参数。<br>例如：<code>void Fun();</code>和<code>void Fun(void);</code>完全等价。</p><h3 id="默认参数的函数"><a href="#默认参数的函数" class="headerlink" title="默认参数的函数"></a>默认参数的函数</h3><p>在说明函数原型时，为一个或多个形参指定默认值。<br>当进行函数调用时，从左向右将实参和形参结合，若未指定足够实参，则保持默认值不变。<br><strong>注意</strong><br>所有默认（缺省值）值必须在最右边。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>在函数声明前加<code>inline</code>关键字，调用时使用函数体中的代码插入到调用函数的语句之处，在运行时不再调用。<br>作用：消除函数调用的系统开销，以提高运行速度。<br>内联函数体内一般不能有循环语句和开关语句。通常只有较短的函数才定义为内联函数。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>当两个以上的函数公用一个函数名，但形参的个数或类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪个函数，这就是函数的重载，被重载的函数称为重载函数。<br><strong>注意</strong>：<br>返回值类型不在参数匹配检查之列，即两个函数除返回值类型不同，其它均相同则是非法的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是C++新增的概念，用来为变量起别名，主要用做函数参数和作为函数值的返回值类型。<br>声明引用的格式：<br><code>数据类型 &amp;引用名=已定义的变量名；</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析</title>
      <link href="/2019/03/06/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/06/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解算法时间复杂度"><a href="#深入理解算法时间复杂度" class="headerlink" title="深入理解算法时间复杂度"></a>深入理解算法时间复杂度</h1><p>算法时间复杂度用来度量算法执行时间的多少，定义为若存在有正常数$c$，$n_0$，使得当$n \ge n_0$时都有$0 \le T(n) \le c \times f(n)$，则$T(n)=O(f(n))$,用大$O$阶表示，其中$n$为问题规模，也就是问题的大小。<br>既然要理解时间复杂度，我们首先理解术语中的两个关键词——“<strong>算法</strong>”和“<strong>时间</strong>”，理解了它俩就成功一半了。</p><ul><li><p>先看“<strong>算法</strong>”，算法是解决特定问题的方法，在计算机领域里需要将算法用计算机能听懂的语言描述给它听，明白之后它才能使用运算能力解决问题。计算机能听懂的语言，也就是一系列的指令。</p></li><li><p>再看“<strong>时间</strong>”，此处的时间指执行算法消耗的时间，也就是计算机执行前面所说的一系列指令的时间。这个时间的影响因素有：</p><ul><li>计算机执行每条指令的速度</li><li>硬件层面编译产生的代码质量</li><li>软件层面算法的好坏(算法使用的策略)</li><li>问题规模</li></ul></li></ul><a id="more"></a><p>在给定软硬件环境下，其实就是你在自己电脑上写算法的时候，算法执行时间只受算法本身的好坏和要处理的问题的规模影响。这样<strong>4个影响因素减少为2个</strong>，简化了问题。</p><p>给定问题规模$n$之后，优秀的算法可能哐哐哐执行几次就搞定了，一般的算法可能吭哧吭哧执行很多很多次才搞定；当给定算法时，问题规模$n$很小时，可能执行几次就搞定，而$n$很大时，就得执行很多次了。所以算法优劣和问题规模$n$改变时，执行次数（基本操作数）将改变，所以执行次数就是算法优劣和问题规模$n$的函数。到此为止，我们得出一个简单的结论：<strong>算法执行时间可以用执行次数表示</strong>。</p><p>给定算法时，执行次数变为问题规模$n$的函数。比如一个算法是$a$，一个算法是$b$，问题规模为$n$，那么执行次数分别为$Ca=f(n)$,$Cb=g(n)$。现在将比较两个算法的执行次数的问题转换为比较两个函数$f(n)$，$g(n)$的问题。那比较两个函数的什么性质呢？当然是比较随着问题规模$n$增大，执行次数的增加情况，也就是$f(n)$，$g(n)$的增长情况。好比让两个人吃一百个包子，一个人一小时吃完，一个人一分钟吃完，明显一分钟吃完的那个人能力强，效率高，吃法(算法)更先进。<br>要比较两个函数的增长情况，最好的办法是比较函数的一阶导，这样最精确，但是考虑到很多时候只需要大体了解算法的优劣就可以了，所以我们就直接考察对增长速度影响最大的一项，这一项就是函数的<strong>最高阶数</strong>。</p><p>既然可以只考虑最高项的阶数，以简化问题，达到估算的目的，为何不这样做呢？和其他领域一样，还得用符号来表示，这个符号就是大名鼎鼎的大$O$。$T(n)=O(f(n))$其中，$T(n)$就是算法的时间复杂度；$f(n)$表示执行与算法优劣和问题规模有关的执行数；$O( )$表示一种运算符号，和$+-\times\div$类似。作用就是去除其他项，包括与最高项相乘的常数，只保留最高项，比如$f(n)=2n^2+1$，$O(f(n))=O(n^2)$。</p><h1 id="运行时间计算的一般法则"><a href="#运行时间计算的一般法则" class="headerlink" title="运行时间计算的一般法则"></a>运行时间计算的一般法则</h1><p>为了对运算时间进行简化分析，我们采用约定：不存在特定的时间单位。因此我们抛弃一些前导的常数和低阶项，从而计算大$O$的运行时间，由于大$O$是上界，绝不要低估程序的运行时间。<br>例如：计算$\sum i^3$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int sum(int n)&#123;</span><br><span class="line">　　  int sum;</span><br><span class="line">⑴　　sum &#x3D; 0;</span><br><span class="line">⑵　　for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">⑶　　　　sum +&#x3D; i * i * i;</span><br><span class="line">　　&#125;</span><br><span class="line">⑷　　return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:所有的声明均不计时间。第一行赋值语句和第四行返回值语句各占一个时间单位。第三行运行一次占$4$各时间单位（一次赋值，两次乘法，一次加法），总共运行$N$次占$4N$个时间单位。第二行占（一次赋值，$N+1$次比较，$N$次自加）共$2N+2$个时间单位。忽略调用方法和返回值的开销，得到总量是$6N+4$个时间单位。因此我们说该方法是$O(N)$的。</p><p>由于我们有了大$O$的结果，因此就存在许多可以采取捷径而不影响最后运行结果的方法。例如在第三行中我们无需知道运行一次到底占几个时间单位，我们只要知道它是$O(1)$的就行，至于赋值语句等与for循环比起可以忽略最后得到的结果还是$O(N)$。所以为了简化分析，我们不必计较具体开销，这使得我们得到一般法则。</p><p><strong>法则一——for循环</strong>：</p><p>一个for循环运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代次数。一般情况下由于大O内部任何简化都是可能的，所以一般简单的for循环得到的结果是$O(N²)$的。</p><p><strong>法则二——嵌套的for循环</strong>：</p><p>从里向外分析循环。在一组嵌套循环内部的一条语句运行时间为该语句的运行时间乘以该组所有的for循环大小的乘积。例如双重for循环内部有一条赋值语句，则结果为$O(N²)$。</p><p><strong>法则三——顺序语句</strong>：</p><p>将各个语句的运行时间求和即可。<br>$(O(f(N）+O（g(N))= max(O(f(N)，O(g(N))$</p><p><strong>法则四——if/else语句</strong>：</p><p>对于程序片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if（条件）</span><br><span class="line"></span><br><span class="line">　　语句</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">　　语句</span><br></pre></td></tr></table></figure><p>一个if/else语句的运行时间不会超过判断的运行时间加上两个语句中运行时间较长的那个语句的运行时间。</p><p><strong>重要结论</strong></p><ul><li><p>如果$T_1(n)=O(f_1(n))$，且$T_2(n)=O(f_2(n))$，那么<br>   $T_1(N）+T_2(N))= max(O(f(N)，O(g(N))$<br>   $T_1(N）*T_2(N))= O(f(N)*g(N))$</p></li><li><p>对任意常数$k$，$log^k{N}=O(N)$。它告诉我们对数增长的非常慢。</p></li></ul><h1 id="符号意义"><a href="#符号意义" class="headerlink" title="符号意义"></a>符号意义</h1><ul><li>$O(1)$</li></ul><p>$O(1)$表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool IsFirstElementNull(IList&lt;string&gt; elements)</span><br><span class="line">&#123;</span><br><span class="line">    return elements[0] &#x3D;&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$O(N)$</li></ul><p>$O(N)$表示一个算法的性能会随着输入数据的大小变化而线性变化。下面的例子同时也表明了大O表示法其实是用来描述一个算法的最差情况的：在<code>for</code>循环中，一旦程序找到了输入数据中与第二个传入的<code>string</code>匹配时，程序就会提前退出，然而大O表示法却总是假定程序会运行到最差情况（在这个例子中，意味着大$O$会表示程序全部循环完成时的性能）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool ContainsValue(IList&lt;string&gt; elements, string value)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var element in elements)</span><br><span class="line">    &#123;</span><br><span class="line">        if (element &#x3D;&#x3D; value) return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$O(N^2)$</li></ul><p>$O(N^2)$表示一个算法的性能将会随着输入数据的增长而呈现出二次增长。最常见的算法就是对输入数据进行嵌套循环。如果嵌套层级不断深入的话，算法的性能将会变为$O(N3)$，$O(N4)$，以此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool ContainsDuplicates(IList&lt;string&gt; elements)</span><br><span class="line">&#123;</span><br><span class="line">    for (var outer &#x3D; 0; outer &lt; elements.Count; outer++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var inner &#x3D; 0; inner &lt; elements.Count; inner++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t compare with self</span><br><span class="line">            if (outer &#x3D;&#x3D; inner) continue;</span><br><span class="line"></span><br><span class="line">            if (elements[outer] &#x3D;&#x3D; elements[inner]) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$O(2^N)$</li></ul><p>$O(2^N)$表示一个算法的性能将会随着输入数据的每次增加而增大两倍。$O(2^N)$的增长曲线是一条爆炸式增长曲线——开始时较为平滑，但数据增长后曲线增长非常陡峭。一个典型的$O(2^N)$方法就是裴波那契数列的递归计算实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Fibonacci(int number)</span><br><span class="line">&#123;</span><br><span class="line">    if (number &lt;&#x3D; 1) return number;</span><br><span class="line"></span><br><span class="line">    return Fibonacci(number - 2) + Fibonacci(number - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对数</li></ul><p>要说明对数情况，稍稍有点复杂，因此我将使用一个非常通用的示例：<br>二分查找是一种用来在有序集合中进行查找的高效算法。二分查找从数据集的中间位置开始，然后用这个中间值和一个目标值进行比较。如果比较结果为相等，则程序返回成功。如果目标值大于中间值，程序会截取从中间值开始到最大值的那段数据集，并重复执行同样的查找方法。想死的，如果目标值小于中间值，程序将会继续在数据集中较小的那一半执行二分查找。二分查找程序会持续的将数据集对等分，以进入下一次循环，直到最终找到与目标值相等的数据后，程序就退出。<br>这类算法的性能就会被描述为$O(logN)$。正是通过这种不断对数据进行对等分的二分查找操作，使得二分查找算法的曲线从一个峰值开始，随着输入数据集的增长而慢慢的变得平缓。用例子来说明的话，例如一个包含10个输入数据的程序需要耗时一秒完成，则一个包含100个输入数据的程序就需要耗时两秒，然后一个包含1000个输入数据的程序就耗时三秒。加倍的输入数据对这类算法的性能结果影响非常小。基于如此，类似于二分查找的对数级算法在处理大量数据集时非常高效。 </p><h1 id="常见算法的大O运行时间"><a href="#常见算法的大O运行时间" class="headerlink" title="常见算法的大O运行时间"></a>常见算法的大O运行时间</h1><p>$O(log n)$：对数时间，这样的算法包括二分查找。<br>$O(n)$：线性时间，这样的算法包括简单查找。<br>$O(n * log n)$：这样的算法包括快速排序。<br>$O(n2)$：这样的算法包括选择排序。<br>$O(n!)$：这样的算法包括旅行商问题的解决方案。</p><p>更多内容请参考：<a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Big_O_notation</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 大O表示法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建个人博客</title>
      <link href="/2019/03/05/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/03/05/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p><blockquote><p>全是静态文件，访问速度快；<br>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；<br>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；<br>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；<br>博客内容可以轻松打包、转移、发布到其它平台；</p></blockquote><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始一切之前，你必须已经：</p><blockquote><p>有一个github账号，没有的话去注册一个；<br>安装了node.js <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a> 并了解相关基础知识；<br>安装了git for windows <a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">官网下载</a>（或者其它git客户端)。</p></blockquote><h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p><strong>几个注意的地方</strong>：</p><blockquote><p>注册的邮箱一定要验证，否则不会成功；<br>仓库名字必须是：username.github.io，其中username是你的用户名；<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久。</p></blockquote><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p>用git bash执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;. ssh           #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key:</p><p><img src="https://i.loli.net/2019/03/05/5c7e7f1102eed.png" alt="20160818_143914_495_9084.png"><br>将刚复制的内容粘贴到key那里，title随便填，保存。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com           #注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;liuxianan&quot;              &#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;           &#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网：<a href="http://hexo.io" target="_blank" rel="noopener">http://hexo.io</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>安装之前先来说几个注意事项：</p><blockquote><ul><li>很多命令既可以用Windows的cmd来完成，也可以使用<code>git bash</code>来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git         bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ul></blockquote><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org            # 使用淘宝镜像源</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;f&#x2F;Workspaces&#x2F;hexo&#x2F;</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>若未装全文件，则执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="https://i.loli.net/2019/03/05/5c7e83be75364.png" alt="20160818_115922_773_1148.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动服务</span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="https://i.loli.net/2019/03/05/5c7e840808051.png" alt="20160818_120700_028_2426.png"><br><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。<br>个人比较喜欢的2个主题：<code>hexo-theme-jekyll</code> 和 <code>hexo-theme-yilia</code>。<br>首先下载这个主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;f&#x2F;Workspaces&#x2F;hexo&#x2F;</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/03/05/5c7e853915b5e.png" alt="20160818_134500_245_0912.png"><br>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下<code>public</code>的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。<br>首先，<code>ssh key</code>肯定要配置好。<br>其次，配置<code>_config.yml</code>中有关<code>deploy</code>的部分：<br>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>后面一种写法是<code>hexo2.x</code>的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>其它命令不确定，部署这个命令一定要用<code>git bash</code>，否则会提示<code>Permission denied (publickey)</code>.<br>打开你的<code>git bash</code>，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会。</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。<br>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>定位到我们的<code>hexo</code>根目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#39;my-first-blog&#39;</span><br></pre></td></tr></table></figure><p><code>hexo</code>会帮我们在<code>_posts</code>下生成相关md文件：<br>我们只需要打开这个文件就可以开始写博客了。<br>一般完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure><p>如何让博文列表不显示全部内容<br>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？<br>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 前言</span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><p><strong>至此，开启你的博客之旅吧！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex常用语法</title>
      <link href="/2019/03/05/LaTex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/05/LaTex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="公式显示位置"><a href="#公式显示位置" class="headerlink" title="公式显示位置"></a>公式显示位置</h1><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>在公式两边各自加上一个$符号即是行内公式<a id="more"></a><br><code>这是文本$a^2+b^2=c^2$这是文本</code><br>显示效果：<br>这是文本$a^2+b^2=c^2$这是文本</p><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><p>在公式两边各自加上两个$符号即是行间公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是文本</span><br><span class="line">$$a^2+b^2&#x3D;c^2$$</span><br><span class="line">这是文本</span><br></pre></td></tr></table></figure><p>显示效果:<br>这是文本<br>$$a^2+b^2=c^2$$<br>这是文本</p><h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>在LaTex中用^和_表明上下标。上下标只对其后面的一个字符起作用，如果上下标的内容超过一个字符，则需要用花括号{ }包裹，否则上下标只对后面的一个符号起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$p^3_&#123;ij&#125; \qquad \sum_&#123;K&#x3D;1&#125;^3 k a^x+y \qquad  \neq a^&#123;x+y&#125;$$</span><br></pre></td></tr></table></figure><p>显示效果：<br>$$p^3_{ij} \qquad \sum_{K=1}^3 k a^x+y \qquad  \neq a^{x+y}$$</p><h2 id="导数符号"><a href="#导数符号" class="headerlink" title="导数符号"></a>导数符号</h2><p>导数符号’是一个特殊的上标，可以适当连用表示多阶导数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x)&#x3D;x^2 \quad f&#39;(x)&#x3D;2x \quad f&#39;&#39;(x)&#x3D;2$$</span><br></pre></td></tr></table></figure><p>$$f(x)=x^2 \quad f’(x)=2x \quad f’’(x)=2$$</p><h2 id="偏导-条件偏导"><a href="#偏导-条件偏导" class="headerlink" title="偏导 条件偏导"></a>偏导 条件偏导</h2><p>偏导符号$\partial$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\left.\frac&#123;\partial f(x,y)&#125;&#123;\partial x&#125;\right|_&#123;x&#x3D;0&#125;$$</span><br></pre></td></tr></table></figure><p>$$\left.\frac{\partial f(x,y)}{\partial x}\right|_{x=0}$$</p><h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><p>如果是简单的分式，可以写成斜分式的形式,如<code>3/8</code>,在latex中分式一般使用<code>\frac{分子}{分母}</code>来书写。不过这种分式的大小在行间公式时正常显示大小，而在行内被极度压缩了。amsmath提供了方便的命令<code>\dfrac{分子}{分母}</code>和<code>\tfrac{分子}{分母}</code>,令用户能够在行内使用正常大小的行内公式。<br><code>斜分式:$3/8\qquad$  压缩分式:$\frac{3}{8}\qquad$ 显示正常大小:$\dfrac{3}{8}$</code><br>斜分式:$3/8\qquad$  压缩分式:$\frac{3}{8}\qquad$ 显示正常大小:$\dfrac{3}{8}$</p><h2 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h2><p>一般的根式使用<code>\sqrt{…}</code>表示，表示n次方根式写成<code>\sqrt[n]{…}</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\sqrt&#123;x&#125; \Leftrightarrow x^&#123;1&#x2F;2&#125;</span><br><span class="line">\quad \sqrt[3]&#123;2&#125;</span><br><span class="line">\quad \sqrt&#123;x^&#123;2&#125;+\sqrt&#123;y&#125;&#125;$</span><br></pre></td></tr></table></figure><p>$\sqrt{x} \Leftrightarrow x^{1/2}<br>\quad \sqrt[3]{2}<br>\quad \sqrt{x^{2}+\sqrt{y}}$<br>特殊的分式形式，如二项式结构，由amsmath宏包的<code>\binom</code>命令生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pascal&#39;s rule is</span><br><span class="line">$$</span><br><span class="line">\binom&#123;n&#125;&#123;k&#125;&#x3D;\binom&#123;n-1&#125;&#123;k&#125;+\binom&#123;n-1&#125;&#123;k-1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>Pascal’s rule is<br>$$<br>\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}<br>$$</p><h2 id="无穷大符号"><a href="#无穷大符号" class="headerlink" title="无穷大符号"></a>无穷大符号</h2><p><code>\infty</code><br>$\infty$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号有$\dots$<code>\dots</code>和$\cdots$<code>(\cdots)</code>两种形式。他们有各自合适的用途：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a_1,a_2,\dots,a_n$</span><br><span class="line">$a_1,a_2,\cdots,a_n$</span><br></pre></td></tr></table></figure><p>$a_1,a_2,\dots,a_n$<br>$a_1,a_2,\cdots,a_n$<br><code>\ldost</code>和<code>\dots</code>是完全等效的，它们既能用在公式中，也用在文本里作为省略号。<br>除此之外，在矩阵中可能会用到竖排的$\vdots$<code>\vdots</code>和斜排的$\ddots$<code>\ddots</code>。</p><h2 id="关系符"><a href="#关系符" class="headerlink" title="关系符"></a>关系符</h2><p>LaTex常见的关系符号除了可以直接输入的=,&gt;,&lt;，其他符号用命令输入，常用的有不等于:<code>\ne</code>$\ne$,大于等于号:<code>\ge</code>$\ge$和小于等于号:<code>\le</code>$\le$,约等于号: <code>\approx</code>$\approx$,等价 <code>\equiv</code>$\equiv$,正比: <code>\propto</code>$\propto$,相似: <code>\sim</code>$\sim$等等。<br>LaTex还提供了自定义二元关系符的命令<code>\stackrel</code>,用于将一个符号叠加在原有的二元关系符之上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f_n(x) \stackrel&#123;*&#125;&#123;\approx&#125; 1</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>f_n(x) \stackrel{*}{\approx} 1<br>$$</p><h2 id="巨算子"><a href="#巨算子" class="headerlink" title="巨算子"></a>巨算子</h2><p>积分号$\int$<code>\int</code>,求和号$\sum$<code>\sum</code>等符号称为巨算子。巨算子在行内公式和行间公式的大小形状有区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在行内显示:$\sum_&#123;i&#x3D;1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $</span><br><span class="line">在行间显示：</span><br><span class="line">$$\sum_&#123;i&#x3D;1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $$</span><br></pre></td></tr></table></figure><p>在行内显示:$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon $<br>在行间显示：<br>$$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon $$</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="行间极限"><a href="#行间极限" class="headerlink" title="行间极限"></a>行间极限</h3><p>行间公式下标默认放在符号的下方，所以直接在极限符号<code>\lim</code>下方写上符号极限范围即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123;\lim_&#123;x \to +\infty&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$${\lim_{x \to +\infty}}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123;\lim_&#123;x \to -\infty&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$${\lim_{x \to -\infty}}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123;\lim_&#123;x \to 0&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$${\lim_{x \to 0}}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123;\lim_&#123;x \to 0^+&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$${\lim_{x \to 0^+}}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123; \lim_&#123;x \to 0&#125; \frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; &#x3D; 3&#125;$$</span><br></pre></td></tr></table></figure><p>$${ \lim_{x \to 0} \frac{3x^2 +7x^3}{x^2 +5x^4} = 3}$$</p><h3 id="行内极限"><a href="#行内极限" class="headerlink" title="行内极限"></a>行内极限</h3><p>行间的下标默认放在右下角，可以使用<code>\limits_{下标}</code>把下标放到符号下方即可。实例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\lim \limits_&#123;x \to -\infty&#125;&#125;$</span><br></pre></td></tr></table></figure><p>${\lim \limits_{x \to -\infty}}$</p><h1 id="集合相关符号"><a href="#集合相关符号" class="headerlink" title="集合相关符号"></a>集合相关符号</h1><h2 id="元素与集合的关系"><a href="#元素与集合的关系" class="headerlink" title="元素与集合的关系"></a>元素与集合的关系</h2><h3 id="属于"><a href="#属于" class="headerlink" title="属于"></a>属于</h3><p><code>\in</code><br>$\in$<br>###不属于<br><code>\notin</code><br>$\notin$</p><h2 id="集合与集合相关的关系"><a href="#集合与集合相关的关系" class="headerlink" title="集合与集合相关的关系"></a>集合与集合相关的关系</h2><h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h3><p><code>\emptyset</code><br>$\emptyset$</p><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p><code>\subset</code><br>$\subset$</p><h3 id="真子集"><a href="#真子集" class="headerlink" title="真子集"></a>真子集</h3><p><code>\subseteq</code><br>$\subseteq$</p><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>大交集符号<code>\bigcap</code>,显示效果:$\bigcap$<br>小交集符号<code>\cap</code>,显示效果:$\cap$</p><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>大并集符号<code>\bigcup</code>,显示效果:$\bigcup$<br>小并集符号<code>\cup</code>,显示效果:$\cup$</p><h1 id="数学重音和上下括号"><a href="#数学重音和上下括号" class="headerlink" title="数学重音和上下括号"></a>数学重音和上下括号</h1><p>数学符号可以像文字一样“加重音”，比如对时间求导的符号$\dot{r}$<code>\dot{r}</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\bar&#123;x_0&#125; \quad \bar&#123;x&#125;_0$</span><br><span class="line">$\vec&#123;x_0&#125; \quad \vec&#123;x&#125;_0$</span><br><span class="line">$\hat&#123;\mathbf&#123;e&#125;_x&#125; \quad</span><br><span class="line">\hat&#123;\mathbf&#123;e&#125;&#125;_x$</span><br></pre></td></tr></table></figure><p>$\bar{x_0} \quad \bar{x}_0$<br>$\vec{x_0} \quad \vec{x}_0$<br>$\hat{\mathbf{e}_x} \quad<br>\hat{\mathbf{e}}_x$<br>LATEX也能为多个字符加重音，包括直接画线的<code>\overline</code>和<code>\underline</code>命令（可叠加使用）、宽重音符号<code>\widehat</code>、表示向量的箭头<code>\overrightarrow</code>等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$0.\overline&#123;3&#125; &#x3D; \underline&#123;\underline&#123;1&#x2F;3&#125;&#125;$</span><br><span class="line">$\hat&#123;XY&#125; \qquad \widehat&#123;XY&#125;$</span><br><span class="line">$\vec&#123;AB&#125; \qquad \overrightarrow&#123;AB&#125;$</span><br></pre></td></tr></table></figure><p>$0.\overline{3} = \underline{\underline{1/3}}$<br>$\hat{XY} \qquad \widehat{XY}$<br>$\vec{AB} \qquad \overrightarrow{AB}$<br>使用<code>\overbrace</code>和<code>\underbrace</code>命令用来生成上/下括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\underbrace&#123;\overbrace&#123;a+b+c&#125;^6</span><br><span class="line">\cdot \overbrace&#123;d+e+f&#125;^7&#125;</span><br><span class="line">_\text&#123;meaning of life&#125; &#x3D; 42$</span><br></pre></td></tr></table></figure><p>$\underbrace{\overbrace{a+b+c}^6<br>\cdot \overbrace{d+e+f}^7}<br>_\text{meaning of life} = 42$</p><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><p>除了作为上下标之外，箭头还用于表示过程。amsmath的<code>\xleftarrow</code>和<code>\xrightarrow</code>命令可以为箭头增加上下标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$ a\xleftarrow&#123;x+y+z&#125; b $$</span><br><span class="line">$$c\xrightarrow[x&lt;y]&#123;a*b*c&#125;d $$</span><br></pre></td></tr></table></figure><p>$$a\xleftarrow{x+y+z} b $$<br>$$c\xrightarrow[x&lt;y]{a<em>b</em>c}d$$</p><h1 id="括号和定界符"><a href="#括号和定界符" class="headerlink" title="括号和定界符"></a>括号和定界符</h1><p>LATEX提供了多种括号和定界符表示公式块的边界。除小括号( )、中括号[ ]之外，其余都是LATEX命令，包括大括号{ }。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;a,b,c&#125; \neq \&#123;a,b,c\&#125;$</span><br></pre></td></tr></table></figure><p>${a,b,c} \neq {a,b,c}$<br>使用<code>\left</code>和<code>\right</code>命令可令括号（定界符）的大小可变，在行间公式中常用。LATEX会自动根据括号内的公式大小决定定界符大小。<code>\left</code>和<code>\right</code>必须成对使用。需要使用单个定界符时，另一个定界符写成<code>\left.</code>或<code>\right.</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$1 + \left(\frac&#123;1&#125;&#123;1-x^&#123;2&#125;&#125;</span><br><span class="line">\right)^3 \qquad</span><br><span class="line">\left.\frac&#123;\partial f&#125;&#123;\partial t&#125;</span><br><span class="line">\right|_&#123;t&#x3D;0&#125;$$</span><br></pre></td></tr></table></figure><p>$$1 + \left(\frac{1}{1-x^{2}}<br>\right)^3 \qquad<br>\left.\frac{\partial f}{\partial t}<br>\right|_{t=0}$$</p><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><h2 id="长公式折行"><a href="#长公式折行" class="headerlink" title="长公式折行"></a>长公式折行</h2><p>通常来讲应当避免写出超过一行而需要折行的长公式。如果一定要折行的话，优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前,其它位置应当避免折行。<br>amsmath宏包的multline环境提供了书写折行长公式的方便环境。它允许用<code>\\\\</code>(markdown中显示:\)折行，将公式编号放在最后一行。多行公式的首行左对齐，末行右对齐，其余行居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;multline&#125;</span><br><span class="line">a + b + c + d + e + f+ g + h + i \\</span><br><span class="line">&#x3D; j + k + l + m + n\\</span><br><span class="line">&#x3D; o + p + q + r + s\\</span><br><span class="line">&#x3D; t + u + v + x + z</span><br><span class="line">\end&#123;multline&#125;$</span><br></pre></td></tr></table></figure><p>$\begin{multline}<br>a + b + c + d + e + f+ g + h + i \<br>= j + k + l + m + n\<br>= o + p + q + r + s\<br>= t + u + v + x + z<br>\end{multline}$</p><h2 id="多行公式-1"><a href="#多行公式-1" class="headerlink" title="多行公式"></a>多行公式</h2><p>更多的情况是，我们需要罗列一系列公式，并令其按照等号对齐。读者可能阅读过其它手册或者资料，知道LATEX提供了eqnarray环境。它按照等号左边——等号——等号右边呈三列对齐，但等号周围的空隙过大，加上公式编号等一些bug，目前已不推荐使用。</p><p>目前最常用的是align环境，它将公式用&amp;隔为两部分并对齐。分隔符通常放在等号左边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp; &#x3D; b + c \\</span><br><span class="line">&amp; &#x3D; d + e</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><p>\begin{align}<br>a &amp; = b + c \<br>&amp; = d + e<br>\end{align}<br><code>align</code>还能够对齐多组公式，除等号前的&amp;之外，公式之间也用&amp;分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;align&#125;</span><br><span class="line">a &amp;&#x3D;1  &amp;  b &amp;&#x3D;2   &amp; c &amp;&#x3D;3   \\</span><br><span class="line">d &amp;&#x3D;-1 &amp;  e &amp;&#x3D;-2  &amp; f &amp;&#x3D;-5</span><br><span class="line">\end&#123;align&#125;$</span><br></pre></td></tr></table></figure><p>$\begin{align}<br>a &amp;=1  &amp;  b &amp;=2   &amp; c &amp;=3   \<br>d &amp;=-1 &amp;  e &amp;=-2  &amp; f &amp;=-5<br>\end{align}$<br>如果我们不需要按等号对齐，只需罗列数个公式，<code>gather</code>将是一个很好用的环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;gather&#125;</span><br><span class="line">a &#x3D; b + c \\</span><br><span class="line">d &#x3D; e + f + g \\</span><br><span class="line">h + i &#x3D; j + k \notag \\</span><br><span class="line">l + m &#x3D; n</span><br><span class="line">\end&#123;gather&#125;$</span><br></pre></td></tr></table></figure><p>$\begin{gather}<br>a = b + c \<br>d = e + f + g \<br>h + i = j + k \notag \<br>l + m = n<br>\end{gather}$</p><h2 id="公式中的间距"><a href="#公式中的间距" class="headerlink" title="公式中的间距"></a>公式中的间距</h2><p>前文提到过，绝大部分时候，数学公式中各元素的间距是根据符号类型自动生成的，需要我们手动调整的情况极少。我们已经认识了两个生成间距的命令<code>\quad</code>和<code>\qquad</code>。在公式中我们还可能用到的间距包括<code>\,</code>、<code>\</code>:、<code>\;</code>以及负间距<code>\!</code>，其中<code>\quad</code>、<code>\qquad</code>和<code>\,</code>在文本和数学环境中可用，后三个命令只用于数学环境。文本中的<code>\␣</code>也能使用在数学公式中。<br>一个常见的用途是修正积分的被积函数$f(x)$和微元$dx$之间的距离。注意微元里的$d$用的是直立体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\int_a^b f(x)\mathrm&#123;d&#125;x</span><br><span class="line">\qquad</span><br><span class="line">\int_a^b f(x)\,\mathrm&#123;d&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\int_a^b f(x)\mathrm{d}x<br>\qquad<br>\int_a^b f(x),\mathrm{d}x<br>$$</p><h1 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h1><p>为了排版二维数组，LATEX提供了array环境，用法与tabular环境极为类似，也需要定义列格式，并用\换行。数组可作为一个公式块，在外套用<code>\left</code>、<code>\right</code>等定界符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$ \mathbf&#123;X&#125; &#x3D; \left(</span><br><span class="line">\begin&#123;array&#125;&#123;cccc&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots &amp; x_&#123;1n&#125;\\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots &amp; x_&#123;2n&#125;\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\</span><br><span class="line">x_&#123;n1&#125; &amp; x_&#123;n2&#125; &amp; \ldots &amp; x_&#123;nn&#125;\\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right) $$</span><br></pre></td></tr></table></figure><p>$$ \mathbf{X} = \left(<br>\begin{array}{cccc}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\<br>\end{array}<br>\right) $$<br>值得注意的是，上一节末尾介绍的aligned等环境也可以用定界符包裹。我们还可以利用空的定界符排版出这样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$|x| &#x3D; \left\&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;rl&#125;</span><br><span class="line">-x &amp; \text&#123;if &#125; x &lt; 0,\\</span><br><span class="line">0 &amp; \text&#123;if &#125; x &#x3D; 0,\\</span><br><span class="line">x &amp; \text&#123;if &#125; x &gt; 0.</span><br><span class="line">\end&#123;array&#125; \right.$$</span><br></pre></td></tr></table></figure><p>$$|x| = \left{<br>\begin{array}{rl}<br>-x &amp; \text{if } x &lt; 0,\<br>0 &amp; \text{if } x = 0,\<br>x &amp; \text{if } x &gt; 0.<br>\end{array} \right.$$</p><h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><p>不过上述例子可以用amsmath提供的cases环境更轻松地完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$ |x| &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">-x &amp; \text&#123;if &#125; x &lt; 0,\\</span><br><span class="line">0 &amp; \text&#123;if &#125; x &#x3D; 0,\\</span><br><span class="line">x &amp; \text&#123;if &#125; x &gt; 0.</span><br><span class="line">\end&#123;cases&#125; $$</span><br></pre></td></tr></table></figure><p>$$ |x| =<br>\begin{cases}<br>-x &amp; \text{if } x &lt; 0,\<br>0 &amp; \text{if } x = 0,\<br>x &amp; \text{if } x &gt; 0.<br>\end{cases} $$<br>我们当然也可以用array环境排版各种矩阵。amsmath宏包还直接提供了多种排版矩阵的环境，包括不带定界符的matrix，以及带各种定界符的矩阵pmatrix（ ）、bmatrix（ ）、Bmatrix（ ）、vmatrix（ ）、Vmatrix（ ）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 \\ 3 &amp; 4</span><br><span class="line">\end&#123;matrix&#125; \qquad</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots &amp; x_&#123;1n&#125;\\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots &amp; x_&#123;2n&#125;\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\</span><br><span class="line">x_&#123;n1&#125; &amp; x_&#123;n2&#125; &amp; \ldots &amp; x_&#123;nn&#125;\\</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>$$\begin{matrix}<br>1 &amp; 2 \ 3 &amp; 4<br>\end{matrix} \qquad<br>\begin{bmatrix}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\<br>x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\<br>\end{bmatrix}$$</p><h1 id="数学符号的字体控制"><a href="#数学符号的字体控制" class="headerlink" title="数学符号的字体控制"></a>数学符号的字体控制</h1><h2 id="数学字母字体"><a href="#数学字母字体" class="headerlink" title="数学字母字体"></a>数学字母字体</h2><p>LATEX允许一部分数学符号切换字体，主要是拉丁字母、数字等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\mathcal&#123;R&#125; \quad \mathfrak&#123;R&#125;</span><br><span class="line">\quad \mathbb&#123;R&#125;$</span><br><span class="line">$$\mathcal&#123;L&#125;</span><br><span class="line">&#x3D; -\frac&#123;1&#125;&#123;4&#125;F_&#123;\mu\nu&#125;F^&#123;\mu\nu&#125;$$</span><br></pre></td></tr></table></figure><p>$\mathcal{R} \quad \mathfrak{R}<br>\quad \mathbb{R}$<br>$$\mathcal{L}<br>= -\frac{1}{4}F_{\mu\nu}F^{\mu\nu}$$</p><h2 id="数学符号的尺寸"><a href="#数学符号的尺寸" class="headerlink" title="数学符号的尺寸"></a>数学符号的尺寸</h2><p><strong>使用<code>\displaystyle</code>命令修改符号尺寸</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">P &#x3D; \frac</span><br><span class="line">&#123;\sum_&#123;i&#x3D;1&#125;^n (x_i- x)(y_i- y)&#125;</span><br><span class="line">&#123;\displaystyle \left[</span><br><span class="line">\sum_&#123;i&#x3D;1&#125;^n (x_i-x)^2</span><br><span class="line">\sum_&#123;i&#x3D;1&#125;^n (y_i-y)^2</span><br><span class="line">\right]^&#123;1&#x2F;2&#125; &#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>P = \frac<br>{\sum_{i=1}^n (x_i- x)(y_i- y)}<br>{\displaystyle \left[<br>\sum_{i=1}^n (x_i-x)^2<br>\sum_{i=1}^n (y_i-y)^2<br>\right]^{1/2} }<br>$$<br>在LaTeX中若用<code>\frac</code>有时会导致字母显示出来很小，解决方案是使用<code>\dfrac</code>。其中<code>\dfra</code>c即为<code>\displaystyle\frac</code>的意思:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x_1^*&#x3D;\dfrac&#123;a_&#123;22&#125;r_1-a_&#123;12&#125;r_2&#125;&#123;a_&#123;11&#125;a_&#123;22&#125;-a_&#123;12&#125;a_&#123;21&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$$x_1^<em>=\dfrac{a_{22}r_1-a_{12}r_2}{a_{11}a_{22}-a_{12}a_{21}}$$<br>*</em>求积符号下多行限制条件**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\prod_&#123;k_0,k_1,\ldots&gt;0\atop k_0+k_1+\cdots&#x3D;n&#125;&#123;A_&#123;k_0&#125;A_&#123;k_1&#125;\cdots A_&#123;k_n&#125;&#125;$$</span><br></pre></td></tr></table></figure><p>$$\prod_{k_0,k_1,\ldots&gt;0\atop k_0+k_1+\cdots=n}{A_{k_0}A_{k_1}\cdots A_{k_n}}$$ </p><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><h2 id="二元关系符"><a href="#二元关系符" class="headerlink" title="二元关系符"></a>二元关系符</h2><table><thead><tr><th>效果</th><th>命令</th><th>效果</th><th>命令</th><th>效果</th><th>命令</th></tr></thead><tbody><tr><td>$&lt;$</td><td>&lt;</td><td>$&gt;$</td><td>&gt;</td><td>$=$</td><td>=</td></tr><tr><td>$\leq$</td><td>\leq or \le</td><td>$\geq$</td><td>\geq or \ge</td><td>$\equiv$</td><td>\equiv</td></tr><tr><td>$\ll$</td><td>\ll</td><td>$\gg$</td><td>\gg</td><td>$\doteq$</td><td>\doteq</td></tr><tr><td>$\prec$</td><td>\prec</td><td>$\succ$</td><td>\succ</td><td>$\sim$</td><td>\sim</td></tr><tr><td>$\preceq$</td><td>\preceq</td><td>$\succeq$</td><td>\succeq</td><td>$\simeq$</td><td>\simeq</td></tr><tr><td>$\subset$</td><td>\subset</td><td>$\subset$</td><td>\subset</td><td>$\subset$</td><td>\subset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td><td>$\subseteq$</td><td>\subseteq</td><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\sqsubset$</td><td>\sqsubset</td><td>$\sqsubset$</td><td>\sqsubset</td><td>$\sqsubset$</td><td>\sqsubset</td></tr><tr><td>$\sqsubseteq$</td><td>\sqsubseteq</td><td>$\sqsubseteq$</td><td>\sqsubseteq</td><td>$\sqsubseteq$</td><td>\sqsubset</td></tr><tr><td>$\in$</td><td>\in</td><td>$\ni$</td><td>\ni or \owns</td><td>$\propto$</td><td>\propto</td></tr><tr><td>$\vdash$</td><td>\vdash</td><td>$\dashv$</td><td>\dashv</td><td>$\models$</td><td>\models</td></tr><tr><td>$\mid$</td><td>\mid</td><td>$\parallel$</td><td>\parallel</td><td>$\perp$</td><td>\perp</td></tr><tr><td>$\smile$</td><td>\smile</td><td>$\frown$</td><td>\frown</td><td>$\asymp$</td><td>\asymp</td></tr><tr><td>$:$</td><td>:</td><td>$\notin$</td><td>\notin</td><td>$\neq$</td><td>\neq or \ne</td></tr><tr><td>## 二元运算符</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>LaTex中的算符大多数是二元运算符，除了直接用键盘可以输入的+，-，*，/外，其他符号用命令输入，常用的符号有乘号：$\times$<code>\times</code>,除号: $\div$<code>\div</code>,点乘: $\cdot$<code>\cdot</code>,加减号 $\pm$<code>\pm</code> 或者 $\mp$<code>\mp</code>等等。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://i.loli.net/2019/03/05/5c7e5807ce5a5.png" alt="二元运算符.png" title="二元运算符"></p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>LaTex希腊字母符号代码就是<code>斜杠+其英文名称</code>，如<code>\alpha</code>:$\alpha$,<code>\beta</code>:$\beta$…等。<br>大写的latex希腊字母就是<code>斜杠+首字母大写的英文名称</code>，如<code>\Gamma</code>:$\Gamma$,<code>\Delta</code>:$\Delta$…。<br><code>\Alpha</code>，<code>\Beta</code>等希腊字母符号不存在，因为它们和拉丁字母A,B等一模一样；小写字母里也不存在<code>\omicron</code>，可以直接用字母o代替，省的打那么长的代码。</p><h2 id="巨算符"><a href="#巨算符" class="headerlink" title="巨算符"></a>巨算符</h2><p><img src="https://i.loli.net/2019/03/05/5c7e5c8dcb62e.png" alt="巨算符.png" title="巨算符"></p><h2 id="箭头-1"><a href="#箭头-1" class="headerlink" title="箭头"></a>箭头</h2><p><img src="https://i.loli.net/2019/03/05/5c7e5c8e133ce.png" alt="箭头.png" title="箭头"><br><img src="https://i.loli.net/2019/03/05/5c7e5c8c674d4.png" alt="顶部箭头.png" title="顶部箭头"></p><h2 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h2><p><img src="https://i.loli.net/2019/03/05/5c7e5c8cd00fe.png" alt="定界符.png" title="定界符"></p><h2 id="公式中的间距-1"><a href="#公式中的间距-1" class="headerlink" title="公式中的间距"></a>公式中的间距</h2><p><img src="https://i.loli.net/2019/03/05/5c7e5c8d7867d.png" alt="公式中的间距.png" title="公式中的间距"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2019/03/03/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/03/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1 标题"></a>1 标题</h1><p>在想要设置为标题的文字前面加#来表示<a id="more"></a><br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h1 id="2-字体"><a href="#2-字体" class="headerlink" title="2 字体"></a>2 字体</h1><ul><li><p><strong>加粗</strong><br>要加粗的文字左右分别用两个*号包起来</p></li><li><p><strong>斜体</strong><br>要倾斜的文字左右分别用一个*号包起来</p></li><li><p><strong>斜体加粗</strong><br>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p><strong>删除线</strong><br>要加删除线的文字左右分别用两个~~号包起来</p></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：<br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h1><p>在引用的文字前加&gt;即可。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br></pre></td></tr></table></figure><p>效果展示：</p><blockquote><p>引用内容</p></blockquote><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4 分割线"></a>4 分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure><h2 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h2><hr><hr><hr><h1 id="5-图片"><a href="#5-图片" class="headerlink" title="5 图片"></a>5 图片</h1><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><h1 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6 超链接"></a>6 超链接</h1><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http:&#x2F;&#x2F;jianshu.com)</span><br><span class="line">[百度](http:&#x2F;&#x2F;baidu.com)</span><br></pre></td></tr></table></figure><p>效果展示：<br><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h1 id="7-列表"><a href="#7-列表" class="headerlink" title="7 列表"></a>7 列表</h1><ul><li><strong>无序列表</strong></li></ul><p>语法：<br>无序列表用 - + * 任何一种都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果展示：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li><p>列表内容</p></li><li><p><strong>有序列表</strong></p></li></ul><p>语法：<br>数字加点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果展示：<br>1.列表内容<br>2.列表内容<br>3.列表内容</p><ul><li><strong>列表嵌套</strong></li></ul><p>语法<br>上一级和下一级之间敲三个空格即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 列表内容</span><br><span class="line">    -列表内容</span><br><span class="line">    -列表内容</span><br><span class="line">    -列表内容</span><br></pre></td></tr></table></figure><p>效果展示：</p><ul><li>列表内容<br>  -列表内容<br>  -列表内容<br>  -列表内容</li></ul><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8 表格"></a>8 表格</h1><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><h1 id="9-代码"><a href="#9-代码" class="headerlink" title="9 代码"></a>9 代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><blockquote><p>`代码内容`</p></blockquote><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><blockquote><p>```<br>      代码…<br>      代码…<br>      代码…<br>  ```</p></blockquote><p>示例：<br>单行代码</p><blockquote><p>`create database hero;`</p></blockquote><p>代码块</p><blockquote><p>```<br>      function fun(){<br>         echo “这是一句非常牛逼的代码”;<br>    }<br>    fun();<br>  ```</p></blockquote><p>效果展示：<br><code>create database hero;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">      echo &quot;这是一句非常牛的代码&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> fun();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
